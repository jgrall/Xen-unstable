#!/usr/bin/env python
#  -*- mode: python; -*-
#============================================================================
# Copyright (C) 2004 Mike Wray <mike.wray@hp.com>
#============================================================================

"""Xen management daemon. Lives in /usr/sbin.
   Provides console server and HTTP management api.

   Run:
   xend start

   Restart:
   xend restart

   The daemon is stopped with:
   xend stop

   The daemon should reconnect to device control interfaces
   and recover its state when restarted.
"""
import os
import sys
import socket
import signal
import time

XCS_PATH    = "/var/lib/xen/xcs_socket"
XCS_EXEC    = "/usr/sbin/xcs"
XCS_PIDFILE = "/var/run/xcs.pid"
XCS_ARGS    = (XCS_EXEC, "-p", XCS_PIDFILE)

# Default install path for Xen binary packages.
sys.path = [ '/usr/lib/python' ] + sys.path
from xen.xend.server import SrvDaemon

class CheckError(ValueError):
    pass

def hline():
    print >>sys.stderr, "*" * 70

def msg(message):
    print >>sys.stderr, "*" * 3, message

def check_logging():
    """Check python logging is installed and raise an error if not.
    Logging is standard from Python 2.3 on.
    """
    try:
        import logging
    except ImportError:
        hline()
        msg("Python logging is not installed.")
        msg("Use 'make install-logging' at the xen root to install.")
        msg("")
        msg("Alternatively download and install from")
        msg("http://www.red-dove.com/python_logging.html")
        hline()
        raise CheckError("logging is not installed")

def check_twisted_version():
    """Check twisted is installed with a supported version and print a warning if not.
    Raises an error if twisted is not installed.
    """
    # Supported twisted release and major version.
    RELEASE = 1
    MAJOR   = 3
    try:
        from twisted.copyright import version
    except ImportError:
        hline()
        msg("The Twisted framework is not installed.")
        msg("Use 'make install-twisted' at the xen root to install.")
        msg("")
        msg("Alternatively download and install version %d.%d or higher" % (RELEASE, MAJOR))
        msg("from http://www.twistedmatrix.com/products")
        hline()
        raise CheckError("twisted is not installed")
        
    
    (release, major, minor) = version.split('.')
    release = int(release)
    major = int(major)
    if release > RELEASE: return
    if release == RELEASE and major >= MAJOR: return
    hline()
    msg("Warning: Twisted version not supported: %s" % version)
    msg("Use Twisted version %d.%d.0 or higher" % (RELEASE, MAJOR))
    hline()

def check_user():
    """Check that the effective user id is 0 (root).
    """
    if os.geteuid() != 0:
        hline()
        msg("Xend must be run as root.")
        hline()
        raise CheckError("invalid user")

def xcs_running():
    """ See if the control switch is running.
    """	
    try:
	xcs_pidfile = open(XCS_PIDFILE)
    except IOError:
	return(0)
    xcs_pidfile.close()
    return 1
    
def start_xcs():
    if (not xcs_running()):
        if os.fork():
            time.sleep(0.1) # let xcs start
        else:
            try:
                os.execvp(XCS_EXEC, XCS_ARGS)
            except:
                hline()
                msg("Tried to start xcs, but failed. Is it installed?")
                hline()
                raise CheckError("couldn't start xcs")
        if (not xcs_running()):
            hline()
            msg("Failed to start the control interface switch.")
            hline()
            raise CheckError("xcs not running")
            
def stop_xcs():
    try:
	xcs_pidfile = open(XCS_PIDFILE)
    except IOError:
	return
    xcs_pid = int(xcs_pidfile.read().strip())
    os.kill(xcs_pid, signal.SIGTERM)
    xcs_pidfile.close()
    
            
def main():
    try:
        check_logging()
        check_twisted_version()
        check_user()
    except CheckError:
        sys.exit(1)
    
    daemon = SrvDaemon.instance()
    if not sys.argv[1:]:
        print 'usage: %s {start|stop|restart}' % sys.argv[0]
    elif os.fork():
        pid, status = os.wait()
        return status >> 8
    elif sys.argv[1] == 'start':
        start_xcs()
        return daemon.start()
    elif sys.argv[1] == 'trace_start':
        start_xcs()
        return daemon.start(trace=1)
    elif sys.argv[1] == 'stop':
        stop_xcs()
        return daemon.stop()
    elif sys.argv[1] == 'restart':
        stop_xcs()
        start_xcs()
        return daemon.stop() or daemon.start()
    elif sys.argv[1] == 'status':
        return daemon.status()
    else:
        print 'not an option:', sys.argv[1]
    return 1

if __name__ == '__main__':
    sys.exit(main())
