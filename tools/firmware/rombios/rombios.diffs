--- /home/leendert/cvs/bochs/bios/rombios.c	2005-05-23 12:18:11.000000000 -0400
+++ rombios.c	2005-06-01 23:46:45.000000000 -0400
@@ -26,6 +26,7 @@
 
 // ROM BIOS for use with Bochs/Plex x86 emulation environment
 
+#define VMXASSIST
 
 // ROM BIOS compatability entry points:
 // ===================================
@@ -170,7 +171,9 @@
 #define BASE_MEM_IN_K   (640 - EBDA_SIZE)
 
   // Define the application NAME
-#ifdef PLEX86
+#ifdef VMXASSIST
+#  define BX_APPNAME "VMXAssist"
+#elif PLEX86
 #  define BX_APPNAME "Plex86"
 #else
 #  define BX_APPNAME "Bochs"
@@ -314,7 +317,6 @@
   ASM_END
   }
   
-#if 0 
   // memcpy of count bytes
     void 
   memcpyb(dseg,doffset,sseg,soffset,count)
@@ -362,6 +364,7 @@
   ASM_END
   }
 
+#if 0 
   // memcpy of count dword
     void 
   memcpyd(dseg,doffset,sseg,soffset,count)
@@ -858,6 +861,7 @@
 static void           write_byte();
 static void           write_word();
 static void           bios_printf();
+static void           copy_e820_table();
 
 static Bit8u          inhibit_mouse_int_and_events();
 static void           enable_mouse_int_and_events();
@@ -1420,6 +1424,16 @@
 ASM_END
 }
 
+#ifdef VMXASSIST
+void
+copy_e820_table()
+{
+  Bit8u nr_entries = read_byte(0x9000, 0x1e8);
+  write_word(0xe000, 0x8, nr_entries);
+  memcpyb(0xe000, 0x10, 0x9000, 0x2d0, nr_entries * 0x14);
+}
+#endif /* VMXASSIST */
+
 #if BX_DEBUG_SERIAL
 /* serial debug port*/
 #define BX_DEBUG_PORT 0x03f8
@@ -1498,6 +1512,9 @@
   if (c == '\n') uart_tx_byte(BX_DEBUG_PORT, '\r');
   uart_tx_byte(BX_DEBUG_PORT, c);
 #endif
+#ifdef VMXASSIST
+  outb(0xE9, c);
+#endif
 #if BX_VIRTUAL_PORTS
   if (action & BIOS_PRINTF_DEBUG) outb(DEBUG_PORT, c);
   if (action & BIOS_PRINTF_INFO) outb(INFO_PORT, c);
@@ -4053,6 +4070,66 @@
          case 0x20: // coded by osmaker aka K.J.
             if(regs.u.r32.edx == 0x534D4150)
             {
+#ifdef VMXASSIST
+		if ((regs.u.r16.bx / 0x14)* 0x14 == regs.u.r16.bx) {
+		    Bit16u e820_table_size = read_word(0xe000, 0x8) * 0x14;
+
+		    if (regs.u.r16.bx + 0x14 <= e820_table_size) {
+			memcpyb(ES, regs.u.r16.di,
+				0xe000, 0x10 + regs.u.r16.bx, 0x14);
+		    }
+		    regs.u.r32.ebx += 0x14;
+		    if ((regs.u.r32.ebx + 0x14 - 1) > e820_table_size)
+			regs.u.r32.ebx = 0;
+		    regs.u.r32.eax = 0x534D4150;
+		    regs.u.r32.ecx = 0x14;
+		    CLEAR_CF();
+		    return;
+		} else if (regs.u.r16.bx == 1) {
+		    extended_memory_size = inb_cmos(0x35);
+		    extended_memory_size <<= 8;
+		    extended_memory_size |= inb_cmos(0x34);
+		    extended_memory_size *= 64;
+		    if (extended_memory_size > 0x3bc000) // greater than EFF00000???
+		    {
+			extended_memory_size = 0x3bc000; // everything after this is reserved memory until we get to 0x100000000
+		    }
+		    extended_memory_size *= 1024;
+		    extended_memory_size += 15728640; // make up for the 16mb of memory that is chopped off
+
+		    if (extended_memory_size <= 15728640)
+		    {
+			extended_memory_size = inb_cmos(0x31);
+			extended_memory_size <<= 8;
+			extended_memory_size |= inb_cmos(0x30);
+			extended_memory_size *= 1024;
+		    }
+
+		    write_word(ES, regs.u.r16.di, 0x0000);
+		    write_word(ES, regs.u.r16.di+2, 0x0010);
+		    write_word(ES, regs.u.r16.di+4, 0x0000);
+		    write_word(ES, regs.u.r16.di+6, 0x0000);
+
+		    write_word(ES, regs.u.r16.di+8, extended_memory_size);
+		    extended_memory_size >>= 16;
+		    write_word(ES, regs.u.r16.di+10, extended_memory_size);
+		    extended_memory_size >>= 16;
+		    write_word(ES, regs.u.r16.di+12, extended_memory_size);
+		    extended_memory_size >>= 16;
+		    write_word(ES, regs.u.r16.di+14, extended_memory_size);
+
+		    write_word(ES, regs.u.r16.di+16, 0x1);
+		    write_word(ES, regs.u.r16.di+18, 0x0);
+
+		    regs.u.r32.ebx = 0;
+		    regs.u.r32.eax = 0x534D4150;
+		    regs.u.r32.ecx = 0x14;
+		    CLEAR_CF();
+		    return;
+		} else { /* AX=E820, DX=534D4150, BX unrecognized */
+		    goto int15_unimplemented;
+		}
+#else
                 switch(regs.u.r16.bx)
                 {
                     case 0:
@@ -4070,6 +4147,7 @@
                         write_word(ES, regs.u.r16.di+18, 0x0);
 
                         regs.u.r32.ebx = 1;
+
                         regs.u.r32.eax = 0x534D4150;
                         regs.u.r32.ecx = 0x14;
                         CLEAR_CF();
@@ -4121,6 +4199,7 @@
                         goto int15_unimplemented;
                         break;
                 }
+#endif
 	    } else {
 	      // if DX != 0x534D4150)
 	      goto int15_unimplemented;
@@ -9497,9 +9576,16 @@
   ;; int 1C already points at dummy_iret_handler (above)
   mov al, #0x34 ; timer0: binary count, 16bit count, mode 2
   out 0x43, al
+#ifdef VMXASSIST
+  mov al, #0x0b ; #0xe90b = 20 Hz (temporary, until we fix xen/vmx support)
+  out 0x40, al ; lsb
+  mov al, #0xe9
+  out 0x40, al ; msb
+#else
   mov al, #0x00 ; maximum count of 0000H = 18.2Hz
   out 0x40, al
   out 0x40, al
+#endif
 
   ;; Keyboard
   SET_INT_VECTOR(0x09, #0xF000, #int09_handler)
@@ -9597,10 +9683,22 @@
   mov al, #0x11 ; send initialisation commands
   out 0x20, al
   out 0xa0, al
+#ifdef VMXASSIST
+  ;; The vm86 emulator expects interrupts to be mapped beyond the reserved
+  ;; vectors (0 through 31). Since rombios fully controls the hardware, we
+  ;; map it the way the emulator needs it and expect that it will do the
+  ;; proper 8086 interrupt translation (that is, master pic base is at 0x8
+  ;; and slave pic base is at 0x70).
+  mov al, #0x20
+  out 0x21, al
+  mov al, #0x28
+  out 0xa1, al
+#else
   mov al, #0x08
   out 0x21, al
   mov al, #0x70
   out 0xa1, al
+#endif
   mov al, #0x04
   out 0x21, al
   mov al, #0x02
@@ -9617,6 +9715,10 @@
 #endif
   out  0xa1, AL ;slave  pic: unmask IRQ 12, 13, 14
 
+#ifdef VMXASSIST
+  call _copy_e820_table
+#endif
+
   call pcibios_init
 
   call rom_scan
