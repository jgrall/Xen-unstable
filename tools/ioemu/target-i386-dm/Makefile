XEN_ROOT=../../..
include $(XEN_ROOT)/tools/Rules.mk
include config.mak
override TARGET_ARCH=i386

#assume we directly put qemu code in tools/, same level as bochs dm(ioemu)
XEN_PATH=../../..
TARGET_PATH=$(SRC_PATH)/target-$(TARGET_ARCH)
VPATH=$(SRC_PATH):$(TARGET_PATH):$(SRC_PATH)/hw:$(SRC_PATH)/audio
DEFINES=-I. -I$(TARGET_PATH) -I$(SRC_PATH) -I$(XEN_PATH)/xen/include/public
DEFINES+= -I$(XEN_PATH)/tools/libxc
ifdef CONFIG_USER_ONLY
VPATH+=:$(SRC_PATH)/linux-user
DEFINES+=-I$(SRC_PATH)/linux-user -I$(SRC_PATH)/linux-user/$(TARGET_ARCH)
endif
CFLAGS=-Wall -O2 -g -fno-strict-aliasing
LDFLAGS=-g
LIBS=
HELPER_CFLAGS=$(CFLAGS)
DYNGEN=../dyngen$(EXESUF)
# user emulator name
QEMU_USER=qemu-$(TARGET_ARCH)
# system emulator name
ifdef CONFIG_SOFTMMU
ifeq ($(TARGET_ARCH), i386)
QEMU_SYSTEM=qemu$(EXESUF)
else
QEMU_SYSTEM=qemu-system-$(TARGET_ARCH)$(EXESUF)
endif
else
QEMU_SYSTEM=qemu-fast
endif

QEMU_SYSTEM=qemu-dm
PROGS=$(QEMU_SYSTEM)

ifdef CONFIG_USER_ONLY
PROGS=$(QEMU_USER)
else
ifeq ($(TARGET_ARCH), i386)

ifeq ($(ARCH), i386)
PROGS+=$(QEMU_SYSTEM)
ifndef CONFIG_SOFTMMU
CONFIG_STATIC=y
endif
else
# the system emulator using soft mmu is portable
ifdef CONFIG_SOFTMMU
PROGS+=$(QEMU_SYSTEM)
endif
endif # ARCH != i386

endif # TARGET_ARCH = i386

ifeq ($(TARGET_ARCH), ppc)

ifeq ($(ARCH), ppc)
PROGS+=$(QEMU_SYSTEM)
endif

ifeq ($(ARCH), i386)
ifdef CONFIG_SOFTMMU
PROGS+=$(QEMU_SYSTEM)
endif
endif # ARCH = i386

ifeq ($(ARCH), amd64)
ifdef CONFIG_SOFTMMU
PROGS+=$(QEMU_SYSTEM)
endif
endif # ARCH = amd64

endif # TARGET_ARCH = ppc

ifeq ($(TARGET_ARCH), sparc)

ifeq ($(ARCH), ppc)
PROGS+=$(QEMU_SYSTEM)
endif

ifeq ($(ARCH), i386)
ifdef CONFIG_SOFTMMU
PROGS+=$(QEMU_SYSTEM)
endif
endif # ARCH = i386

ifeq ($(ARCH), amd64)
ifdef CONFIG_SOFTMMU
PROGS+=$(QEMU_SYSTEM)
endif
endif # ARCH = amd64

endif # TARGET_ARCH = sparc
endif # !CONFIG_USER_ONLY

ifdef CONFIG_STATIC
LDFLAGS+=-static
endif

ifeq ($(ARCH),i386)
CFLAGS+=-fomit-frame-pointer
OP_CFLAGS=$(CFLAGS) -mpreferred-stack-boundary=2
ifeq ($(HAVE_GCC3_OPTIONS),yes)
OP_CFLAGS+= -falign-functions=0 -fno-gcse
else
OP_CFLAGS+= -malign-functions=0
endif

ifdef TARGET_GPROF
USE_I386_LD=y
endif
ifdef CONFIG_STATIC
USE_I386_LD=y
endif
ifdef USE_I386_LD
LDFLAGS+=-Wl,-T,$(SRC_PATH)/i386.ld
else
# WARNING: this LDFLAGS is _very_ tricky : qemu is an ELF shared object
# that the kernel ELF loader considers as an executable. I think this
# is the simplest way to make it self virtualizable!
LDFLAGS+=-Wl,-shared
endif
endif

ifeq ($(ARCH),amd64)
OP_CFLAGS=$(CFLAGS) -falign-functions=0
LDFLAGS+=-Wl,-T,$(SRC_PATH)/amd64.ld
endif

ifeq ($(ARCH),ppc)
CFLAGS+= -D__powerpc__
OP_CFLAGS=$(CFLAGS)
LDFLAGS+=-Wl,-T,$(SRC_PATH)/ppc.ld
endif

ifeq ($(ARCH),s390)
OP_CFLAGS=$(CFLAGS)
LDFLAGS+=-Wl,-T,$(SRC_PATH)/s390.ld
endif

ifeq ($(ARCH),sparc)
CFLAGS+=-m32 -ffixed-g1 -ffixed-g2 -ffixed-g3 -ffixed-g6
LDFLAGS+=-m32
OP_CFLAGS=$(CFLAGS) -fno-delayed-branch -ffixed-i0
HELPER_CFLAGS=$(CFLAGS) -ffixed-i0 -mflat
# -static is used to avoid g1/g3 usage by the dynamic linker
LDFLAGS+=-Wl,-T,$(SRC_PATH)/sparc.ld -static
endif

ifeq ($(ARCH),sparc64)
CFLAGS+=-m64 -ffixed-g1 -ffixed-g2 -ffixed-g3 -ffixed-g6
LDFLAGS+=-m64
OP_CFLAGS=$(CFLAGS) -fno-delayed-branch -ffixed-i0
endif

ifeq ($(ARCH),alpha)
# -msmall-data is not used because we want two-instruction relocations
# for the constant constructions
OP_CFLAGS=-Wall -O2 -g
# Ensure there's only a single GP
CFLAGS += -msmall-data
LDFLAGS+=-Wl,-T,$(SRC_PATH)/alpha.ld
endif

ifeq ($(ARCH),ia64)
OP_CFLAGS=$(CFLAGS)
endif

ifeq ($(ARCH),arm)
OP_CFLAGS=$(CFLAGS) -mno-sched-prolog
LDFLAGS+=-Wl,-T,$(SRC_PATH)/arm.ld
endif

ifeq ($(ARCH),m68k)
OP_CFLAGS=$(CFLAGS) -fomit-frame-pointer
LDFLAGS+=-Wl,-T,m68k.ld
endif

ifeq ($(HAVE_GCC3_OPTIONS),yes)
# very important to generate a return at the end of every operation
OP_CFLAGS+=-fno-reorder-blocks -fno-optimize-sibling-calls
endif

ifeq ($(CONFIG_DARWIN),yes)
OP_CFLAGS+= -mdynamic-no-pic
endif

#########################################################

DEFINES+=-D_GNU_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE
LIBS+=-lm -L../../libxc -L../../libxutil -lxc -lxutil
ifndef CONFIG_USER_ONLY
LIBS+=-lz
endif
ifdef CONFIG_WIN32
LIBS+=-lwinmm -lws2_32 -liphlpapi
endif

# profiling code
ifdef TARGET_GPROF
LDFLAGS+=-p
main.o: CFLAGS+=-p
endif

OBJS= elfload.o main.o syscall.o mmap.o signal.o path.o osdep.o thunk.o 
ifeq ($(TARGET_ARCH), i386)
OBJS+= vm86.o
endif
ifeq ($(TARGET_ARCH), arm)
OBJS+=nwfpe/softfloat.o nwfpe/fpa11.o nwfpe/fpa11_cpdo.o \
nwfpe/fpa11_cpdt.o nwfpe/fpa11_cprt.o nwfpe/fpopcode.o nwfpe/single_cpdo.o \
 nwfpe/double_cpdo.o nwfpe/extended_cpdo.o
endif
SRCS:= $(OBJS:.o=.c)
OBJS+= libqemu.a

# cpu emulator library
LIBOBJS=

ifeq ($(TARGET_ARCH), i386)
LIBOBJS+= helper2.o
ifeq ($(ARCH), i386)
LIBOBJS+=translate-copy.o
endif
endif

ifeq ($(TARGET_ARCH), ppc)
LIBOBJS+= op_helper.o helper.o
endif

ifeq ($(TARGET_ARCH), sparc)
LIBOBJS+= op_helper.o helper.o
endif

all: $(PROGS)

$(QEMU_USER): $(OBJS)
	$(CC) $(LDFLAGS) -o $@ $^  $(LIBS)
ifeq ($(ARCH),alpha)
# Mark as 32 bit binary, i. e. it will be mapped into the low 31 bit of
# the address space (31 bit so sign extending doesn't matter)
	echo -ne '\001\000\000\000' | dd of=qemu bs=1 seek=48 count=4 conv=notrunc
endif

# must use static linking to avoid leaving stuff in virtual address space
VL_OBJS=vl.o exec.o monitor.o osdep.o block.o readline.o pci.o console.o 
#VL_OBJS+=block-cow.o block-qcow.o block-vmdk.o block-cloop.o
VL_OBJS+= block-cloop.o

SOUND_HW = sb16.o
AUDIODRV = audio.o noaudio.o wavaudio.o
ifdef CONFIG_SDL
AUDIODRV += sdlaudio.o
endif
ifdef CONFIG_OSS
AUDIODRV += ossaudio.o
endif

pc.o: DEFINES := -DUSE_SB16 $(DEFINES)

ifdef CONFIG_ADLIB
SOUND_HW += fmopl.o adlib.o
endif

ifdef CONFIG_FMOD
AUDIODRV += fmodaudio.o
audio.o fmodaudio.o: DEFINES := -I$(CONFIG_FMOD_INC) $(DEFINES)
LIBS += $(CONFIG_FMOD_LIB)
endif

# Hardware support
VL_OBJS+= ide.o ne2000.o pckbd.o vga.o dma.o
VL_OBJS+= fdc.o mc146818rtc.o serial.o i8259.o i8254.o pc.o

ifeq ($(TARGET_ARCH), ppc)
VL_OBJS+= ppc.o ide.o ne2000.o pckbd.o vga.o $(SOUND_HW) dma.o $(AUDIODRV)
VL_OBJS+= mc146818rtc.o serial.o i8259.o i8254.o fdc.o m48t59.o
VL_OBJS+= ppc_prep.o ppc_chrp.o cuda.o adb.o openpic.o mixeng.o
endif
ifeq ($(TARGET_ARCH), sparc)
VL_OBJS+= sun4m.o tcx.o lance.o iommu.o sched.o m48t08.o magic-load.o timer.o
endif
ifdef CONFIG_GDBSTUB
VL_OBJS+=gdbstub.o 
endif
ifdef CONFIG_VNC
VL_OBJS+=vnc.o
endif
ifdef CONFIG_SDL
VL_OBJS+=sdl.o
endif
ifdef CONFIG_SLIRP
DEFINES+=-I$(SRC_PATH)/slirp
SLIRP_OBJS=cksum.o if.o ip_icmp.o ip_input.o ip_output.o \
slirp.o mbuf.o misc.o sbuf.o socket.o tcp_input.o tcp_output.o \
tcp_subr.o tcp_timer.o udp.o bootp.o debug.o tftp.o
VL_OBJS+=$(addprefix slirp/, $(SLIRP_OBJS))
endif

VL_LDFLAGS=
# specific flags are needed for non soft mmu emulator
ifdef CONFIG_STATIC
VL_LDFLAGS+=-static
endif
VL_LDFLAGS+=-Wl,-T,$(SRC_PATH)/$(XEN_TARGET_ARCH).ld
ifndef CONFIG_DARWIN
ifndef CONFIG_WIN32
VL_LIBS=-lutil
endif
endif

$(QEMU_SYSTEM): $(VL_OBJS) libqemu.a
	$(CC) $(VL_LDFLAGS) -o $@ $^ $(LIBS) $(SDL_LIBS) $(VNC_LIBS) $(VL_LIBS)

vnc.o: vnc.c keyboard_rdesktop.c
	$(CC) $(CFLAGS) $(DEFINES) $(VNC_CFLAGS) -c -o $@ $<

sdl.o: sdl.c keyboard_rdesktop.c
	$(CC) $(CFLAGS) $(DEFINES) $(SDL_CFLAGS) -c -o $@ $<

sdlaudio.o: sdlaudio.c
	$(CC) $(CFLAGS) $(DEFINES) $(SDL_CFLAGS) -c -o $@ $<

depend: $(SRCS)
	$(CC) -MM $(CFLAGS) $(DEFINES) $^ 1>.depend

# libqemu 

libqemu.a: $(LIBOBJS)
	rm -f $@
	$(AR) rcs $@ $(LIBOBJS)

translate.o: translate.c gen-op.h opc.h cpu.h

translate-all.o: translate-all.c op.h opc.h cpu.h

op.h: op.o $(DYNGEN)
	$(DYNGEN) -o $@ $<

opc.h: op.o $(DYNGEN)
	$(DYNGEN) -c -o $@ $<

gen-op.h: op.o $(DYNGEN)
	$(DYNGEN) -g -o $@ $<

op.o: op.c
	$(CC) $(OP_CFLAGS) $(DEFINES) -c -o $@ $<

helper.o: helper.c
	$(CC) $(HELPER_CFLAGS) $(DEFINES) -c -o $@ $<

ifeq ($(TARGET_ARCH), i386)
op.o: op.c opreg_template.h ops_template.h ops_template_mem.h ops_mem.h
endif

ifeq ($(TARGET_ARCH), arm)
op.o: op.c op_template.h
endif

ifeq ($(TARGET_ARCH), sparc)
op.o: op.c op_template.h op_mem.h
endif

ifeq ($(TARGET_ARCH), ppc)
op.o: op.c op_template.h op_mem.h
op_helper.o: op_helper_mem.h
endif

mixeng.o: mixeng.c mixeng.h mixeng_template.h

%.o: %.c
	$(CC) $(CFLAGS) $(DEFINES) -c -o $@ $<

%.o: %.S
	$(CC) $(DEFINES) -c -o $@ $<

clean:
	rm -rf *.o  *.a *~ $(PROGS) gen-op.h opc.h op.h nwfpe slirp qemu-vgaram-bin

install: all 
	if [ ! -d $(DESTDIR)$(bindir) ];then mkdir -p $(DESTDIR)$(bindir);fi
	if [ ! -d $(DESTDIR)$(configdir) ];then mkdir -p $(DESTDIR)$(configdir);fi
ifneq ($(PROGS),)
	install -m 755 -s $(PROGS) "$(DESTDIR)$(bindir)"
endif
	install -m 755 device-model "$(DESTDIR)$(bindir)"
	install -m 755 qemu-ifup "$(DESTDIR)$(configdir)"
	gunzip -c qemu-vgaram-bin.gz >qemu-vgaram-bin 
	install -m 755 qemu-vgaram-bin "$(DESTDIR)$(configdir)"
ifneq ($(wildcard .depend),)
include .depend
endif
