Index: ioemu/Makefile.target
===================================================================
--- ioemu.orig/Makefile.target	2006-08-17 19:49:50.228216099 +0100
+++ ioemu/Makefile.target	2006-08-17 19:50:02.405870095 +0100
@@ -357,6 +357,7 @@
 VL_OBJS+= fdc.o mc146818rtc.o serial.o pc.o
 VL_OBJS+= cirrus_vga.o mixeng.o parallel.o acpi.o piix_pci.o
 VL_OBJS+= usb-uhci.o
+VL_OBJS+= piix4acpi.o
 DEFINES += -DHAS_AUDIO
 endif
 ifeq ($(TARGET_BASE_ARCH), ppc)
Index: ioemu/hw/pc.c
===================================================================
--- ioemu.orig/hw/pc.c	2006-08-17 19:49:59.312212039 +0100
+++ ioemu/hw/pc.c	2006-08-17 19:50:02.406869984 +0100
@@ -874,13 +874,19 @@
 
     cmos_init(ram_size, boot_device, bs_table, timeoffset);
 
+    /* using PIIX4 acpi model */
+    if (pci_enabled && acpi_enabled)
+        pci_piix4_acpi_init(pci_bus, piix3_devfn + 2);
+
     if (pci_enabled && usb_enabled) {
-        usb_uhci_init(pci_bus, piix3_devfn + 2);
+        usb_uhci_init(pci_bus, piix3_devfn + (acpi_enabled ? 3 : 2));
     }
 
+#ifndef CONFIG_DM
     if (pci_enabled && acpi_enabled) {
         piix4_pm_init(pci_bus, piix3_devfn + 3);
     }
+#endif /* !CONFIG_DM */
 
 #if 0
     /* ??? Need to figure out some way for the user to
@@ -903,8 +909,10 @@
     /* XXX: should be done in the Bochs BIOS */
     if (pci_enabled) {
         pci_bios_init();
+#ifndef CONFIG_DM
         if (acpi_enabled)
             acpi_bios_init();
+#endif /* !CONFIG_DM */
     }
 }
 
Index: ioemu/hw/piix4acpi.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ ioemu/hw/piix4acpi.c	2006-08-17 19:50:02.407869874 +0100
@@ -0,0 +1,388 @@
+/*
+ * PIIX4 ACPI controller emulation
+ *
+ * Winston liwen Wang, winston.l.wang@intel.com
+ * Copyright (c) 2006 , Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+
+#include "vl.h"
+#define FREQUENCE_PMTIMER  3753425
+/* acpi register bit define here  */
+
+/* PM1_STS 						*/
+#define TMROF_STS 	  (1 << 0)
+#define BM_STS 	  	  (1 << 4)
+#define GBL_STS 	  (1 << 5)
+#define PWRBTN_STS 	  (1 << 8)
+#define RTC_STS 	  (1 << 10)
+#define PRBTNOR_STS       (1 << 11)
+#define WAK_STS 	  (1 << 15)
+/* PM1_EN						*/
+#define TMROF_EN          (1 << 0)
+#define GBL_EN            (1 << 5)
+#define PWRBTN_EN         (1 << 8)
+#define RTC_EN   	  (1 << 10)
+/* PM1_CNT						*/
+#define SCI_EN            (1 << 0)
+#define GBL_RLS           (1 << 2)
+#define SLP_EN   	  (1 << 13)
+
+typedef struct AcpiDeviceState AcpiDeviceState;
+AcpiDeviceState *acpi_device_table;
+
+/* Bits of PM1a register define here  */
+typedef struct PM1Event_BLK {
+    uint16_t pm1_status; /* pm1a_EVT_BLK */
+    uint16_t pm1_enable; /* pm1a_EVT_BLK+2 */
+}PM1Event_BLK;
+
+typedef struct PCIAcpiState {
+    PCIDevice dev;
+    uint16_t irq;
+    uint16_t pm1_status; /* pm1a_EVT_BLK */
+    uint16_t pm1_enable; /* pm1a_EVT_BLK+2 */
+    uint16_t pm1_control; /* pm1a_ECNT_BLK */
+    uint32_t pm1_timer; /* pmtmr_BLK */
+} PCIAcpiState;
+
+static PCIAcpiState *acpi_state;
+
+static inline void acpi_set_irq(PCIAcpiState *s)
+{
+/* no real SCI event need for now, so comment the following line out */
+/*  pic_set_irq(s->irq, 1); */
+    printf("acpi_set_irq: s->irq %x \n",s->irq);
+}
+
+static void acpi_reset(PCIAcpiState *s)
+{
+    uint8_t *pci_conf;
+    pci_conf = s->dev.config;
+
+    pci_conf[0x42] = 0x00;
+    pci_conf[0x43] = 0x00;
+    s->irq = 9;
+    s->pm1_status = 0;
+    s->pm1_enable = 0x00;    /* TMROF_EN should cleared */
+    s->pm1_control = SCI_EN; /* SCI_EN */
+    s->pm1_timer = 0;
+}
+
+/*byte access  */
+static void acpiPm1Status_writeb(void *opaque, uint32_t addr, uint32_t val)
+{
+    PCIAcpiState *s = opaque;
+
+    if ((val&TMROF_STS)==TMROF_STS)
+        s->pm1_status = s->pm1_status&!TMROF_STS;
+
+    if ((val&GBL_STS)==GBL_STS)
+        s->pm1_status = s->pm1_status&!GBL_STS;     
+    
+/*     printf("acpiPm1Status_writeb \n addr %x val:%x pm1_status:%x \n", addr, val,s->pm1_status); */
+}
+
+static uint32_t acpiPm1Status_readb(void *opaque, uint32_t addr)
+{
+    PCIAcpiState *s = opaque;
+    uint32_t val;
+
+    val = s->pm1_status;
+/*         printf("acpiPm1Status_readb \n addr %x val:%x\n", addr, val); */
+
+   return val;
+}
+
+static void acpiPm1StatusP1_writeb(void *opaque, uint32_t addr, uint32_t val)
+{
+    PCIAcpiState *s = opaque;
+
+     s->pm1_status = (val<<8)||(s->pm1_status);
+/*     printf("acpiPm1StatusP1_writeb \n addr %x val:%x\n", addr, val); */
+}
+
+static uint32_t acpiPm1StatusP1_readb(void *opaque, uint32_t addr)
+{
+    PCIAcpiState *s = opaque;
+    uint32_t val;
+
+    val = (s->pm1_status)>>8;
+    printf("acpiPm1StatusP1_readb \n addr %x val:%x\n", addr, val);
+
+    return val;
+}
+
+static void acpiPm1Enable_writeb(void *opaque, uint32_t addr, uint32_t val)
+{
+    PCIAcpiState *s = opaque;
+
+    s->pm1_enable = val;
+/*   printf("acpiPm1Enable_writeb \n addr %x val:%x\n", addr, val); */
+}
+
+static uint32_t acpiPm1Enable_readb(void *opaque, uint32_t addr)
+{
+    PCIAcpiState *s = opaque;
+    uint32_t val;
+
+    val = (s->pm1_enable)||0x1;
+/*  printf("acpiPm1Enable_readb \n addr %x val:%x\n", addr, val); */
+
+    return val;
+}
+
+static void acpiPm1EnableP1_writeb(void *opaque, uint32_t addr, uint32_t val)
+{
+    PCIAcpiState *s = opaque;
+
+    s->pm1_enable = (val<<8)||(s->pm1_enable);
+/*    printf("acpiPm1EnableP1_writeb \n addr %x val:%x\n", addr, val); */
+
+}
+
+static uint32_t acpiPm1EnableP1_readb(void *opaque, uint32_t addr)
+{
+    PCIAcpiState *s = opaque;
+    uint32_t val;
+
+    val = (s->pm1_enable)>>8;
+/*  printf("acpiPm1EnableP1_readb \n addr %x val:%x\n", addr, val); */
+
+    return val;
+}
+
+static void acpiPm1Control_writeb(void *opaque, uint32_t addr, uint32_t val)
+{
+    PCIAcpiState *s = opaque;
+
+    s->pm1_control = val;
+/*  printf("acpiPm1Control_writeb \n addr %x val:%x\n", addr, val); */
+
+}
+
+static uint32_t acpiPm1Control_readb(void *opaque, uint32_t addr)
+{
+    PCIAcpiState *s = opaque;
+    uint32_t val;
+
+    val = s->pm1_control;
+/*    printf("acpiPm1Control_readb \n addr %x val:%x\n", addr, val); */
+
+    return val;
+}
+
+static void acpiPm1ControlP1_writeb(void *opaque, uint32_t addr, uint32_t val)
+{
+    PCIAcpiState *s = opaque;
+
+    s->pm1_control = (val<<8)||(s->pm1_control);
+/*    printf("acpiPm1ControlP1_writeb \n addr %x val:%x\n", addr, val); */
+
+} 
+
+static uint32_t acpiPm1ControlP1_readb(void *opaque, uint32_t addr)
+{
+    PCIAcpiState *s = opaque;
+    uint32_t val;
+
+    val = (s->pm1_control)>>8;
+/*    printf("acpiPm1ControlP1_readb \n addr %x val:%x\n", addr, val); */
+
+    return val;
+}
+
+
+/* word access   */
+
+static void acpiPm1Status_writew(void *opaque, uint32_t addr, uint32_t val)
+{
+    PCIAcpiState *s = opaque;
+
+    if ((val&TMROF_STS)==TMROF_STS)
+        s->pm1_status = s->pm1_status&!TMROF_STS;
+
+    if ((val&GBL_STS)==GBL_STS)
+        s->pm1_status = s->pm1_status&!GBL_STS;     
+
+/*    printf("acpiPm1Status_writew \n addr %x val:%x pm1_status:%x \n", addr, val,s->pm1_status); */
+}
+
+static uint32_t acpiPm1Status_readw(void *opaque, uint32_t addr)
+{
+    PCIAcpiState *s = opaque;
+    uint32_t val;
+
+    val = s->pm1_status;
+/*    printf("acpiPm1Status_readw \n addr %x val:%x\n", addr, val); */
+
+    return val;
+}
+
+static void acpiPm1Enable_writew(void *opaque, uint32_t addr, uint32_t val)
+{
+    PCIAcpiState *s = opaque;
+
+    s->pm1_enable = val;
+/*    printf("acpiPm1Enable_writew \n addr %x val:%x\n", addr, val); */
+
+}
+
+static uint32_t acpiPm1Enable_readw(void *opaque, uint32_t addr)
+{
+    PCIAcpiState *s = opaque;
+    uint32_t val;
+
+    val = s->pm1_enable;
+/*    printf("acpiPm1Enable_readw \n addr %x val:%x\n", addr, val); */
+
+   return val;
+}
+
+static void acpiPm1Control_writew(void *opaque, uint32_t addr, uint32_t val)
+{
+    PCIAcpiState *s = opaque;
+
+    s->pm1_control = val;
+/*    printf("acpiPm1Control_writew \n addr %x val:%x\n", addr, val); */
+
+} 
+
+static uint32_t acpiPm1Control_readw(void *opaque, uint32_t addr)
+{
+    PCIAcpiState *s = opaque;
+    uint32_t val;
+
+    val = s->pm1_control;
+/*    printf("acpiPm1Control_readw \n addr %x val:%x\n", addr, val);  */
+
+    return val;
+}
+
+/* dword access */
+
+static void acpiPm1Event_writel(void *opaque, uint32_t addr, uint32_t val)
+{
+    PCIAcpiState *s = opaque;
+
+    s->pm1_status = val;
+    s->pm1_enable = val>>16;
+/*     printf("acpiPm1Event_writel \n addr %x val:%x \n", addr, val); */
+
+}
+
+static void acpiPm1Event_readl(void *opaque, uint32_t addr)
+{
+    PCIAcpiState *s = opaque;
+    uint32_t val;
+
+    val=s->pm1_status|(s->pm1_enable<<16);
+/*    printf("acpiPm1Event_readl \n addr %x val:%x\n", addr, val);    */
+}
+
+static void acpiPm1Timer_writel(void *opaque, uint32_t addr, uint32_t val)
+{
+    PCIAcpiState *s = opaque;
+
+    s->pm1_timer = val;
+/*    printf("acpiPm1Timer_writel \n addr %x val:%x\n", addr, val); */
+}
+
+static uint32_t acpiPm1Timer_readl(void *opaque, uint32_t addr)
+{
+    PCIAcpiState *s = opaque;
+    uint32_t val;
+
+    val = s->pm1_timer;
+/*    printf("acpiPm1Timer_readl \n addr %x val:%x\n", addr, val); */
+    return val;
+}
+
+static void acpi_map(PCIDevice *pci_dev, int region_num,
+                    uint32_t addr, uint32_t size, int type)
+{
+    PCIAcpiState *d = (PCIAcpiState *)pci_dev;
+
+    printf("register acpi io \n");
+
+    /* Byte access */
+    register_ioport_write(addr, 1, 1, acpiPm1Status_writeb, d);
+    register_ioport_read(addr, 1, 1, acpiPm1Status_readb, d);
+    register_ioport_write(addr+1, 1, 1, acpiPm1StatusP1_writeb, d);
+    register_ioport_read(addr+1, 1, 1, acpiPm1StatusP1_readb, d);
+
+    register_ioport_write(addr + 2, 1, 1, acpiPm1Enable_writeb, d);
+    register_ioport_read(addr + 2, 1, 1, acpiPm1Enable_readb, d);
+    register_ioport_write(addr + 2 +1, 1, 1, acpiPm1EnableP1_writeb, d);
+    register_ioport_read(addr + 2 +1, 1, 1, acpiPm1EnableP1_readb, d);
+
+    register_ioport_write(addr + 4, 1, 1, acpiPm1Control_writeb, d);
+    register_ioport_read(addr + 4, 1, 1, acpiPm1Control_readb, d);
+    register_ioport_write(addr + 4 + 1, 1, 1, acpiPm1ControlP1_writeb, d);
+    register_ioport_read(addr + 4 +1, 1, 1, acpiPm1ControlP1_readb, d);	
+
+    /* Word access */
+    register_ioport_write(addr, 2, 2, acpiPm1Status_writew, d);
+    register_ioport_read(addr, 2, 2, acpiPm1Status_readw, d);
+
+    register_ioport_write(addr + 2, 2, 2, acpiPm1Enable_writew, d);
+    register_ioport_read(addr + 2, 2, 2, acpiPm1Enable_readw, d); 
+
+    register_ioport_write(addr + 4, 2, 2, acpiPm1Control_writew, d);
+    register_ioport_read(addr + 4, 2, 2, acpiPm1Control_readw, d);
+
+    /* DWord access */
+    register_ioport_write(addr, 4, 4, acpiPm1Event_writel, d);
+    register_ioport_read(addr, 4, 4, acpiPm1Event_readl, d);
+		
+    register_ioport_write(addr + 8, 4, 4, acpiPm1Timer_writel, d);
+    register_ioport_read(addr + 8, 4, 4, acpiPm1Timer_readl, d);
+}
+													
+
+/* PIIX4 acpi pci configuration space, func 2 */
+void pci_piix4_acpi_init(PCIBus *bus, int devfn)
+{
+    PCIAcpiState *d;
+    uint8_t *pci_conf;
+
+    /* register a function 2 of PIIX4 */
+    d = (PCIAcpiState *)pci_register_device(
+        bus, "PIIX4 ACPI", sizeof(PCIAcpiState),
+        devfn, NULL, NULL);
+
+    acpi_state = d;
+    pci_conf = d->dev.config;
+    pci_conf[0x00] = 0x86;  /* Intel */
+    pci_conf[0x01] = 0x80;
+    pci_conf[0x02] = 0x13;
+    pci_conf[0x03] = 0x71;
+    pci_conf[0x08] = 0x01;  /* B0 stepping */
+    pci_conf[0x09] = 0x00;  /* base class */
+    pci_conf[0x0a] = 0x80;  /* Sub class */
+    pci_conf[0x0b] = 0x06;
+    pci_conf[0x0e] = 0x00;
+    pci_conf[0x3d] = 0x01;  /* Hardwired to PIRQA is used */
+
+    pci_register_io_region((PCIDevice *)d, 4, 0x10,
+                           PCI_ADDRESS_SPACE_IO, acpi_map);
+
+    acpi_reset (d);
+}
Index: ioemu/vl.c
===================================================================
--- ioemu.orig/vl.c	2006-08-17 19:49:59.315211708 +0100
+++ ioemu/vl.c	2006-08-17 19:50:02.410869542 +0100
@@ -156,7 +156,7 @@
 #else
 #define MAX_CPUS 1
 #endif
-int acpi_enabled = 1;
+int acpi_enabled = 0;
 int fd_bootchk = 1;
 
 extern int vcpus;
@@ -5341,6 +5341,7 @@
            "-loadvm file    start right away with a saved state (loadvm in monitor)\n"
 	   "-vnc display    start a VNC server on display\n"
            "-timeoffset     time offset (in seconds) from local time\n"
+           "-acpi           disable or enable ACPI of HVM domain \n"
            "\n"
            "During emulation, the following keys are useful:\n"
            "ctrl-alt-f      toggle full screen\n"
@@ -5426,6 +5427,7 @@
     QEMU_OPTION_d,
     QEMU_OPTION_vcpus,
     QEMU_OPTION_timeoffset,
+    QEMU_OPTION_acpi,
 };
 
 typedef struct QEMUOption {
@@ -5509,6 +5511,7 @@
     { "d", HAS_ARG, QEMU_OPTION_d },
     { "vcpus", 1, QEMU_OPTION_vcpus },
     { "timeoffset", HAS_ARG, QEMU_OPTION_timeoffset },
+    { "acpi", 0, QEMU_OPTION_acpi },
     { NULL },
 };
 
@@ -6256,6 +6259,9 @@
             case QEMU_OPTION_timeoffset:
                 timeoffset = strtol(optarg, NULL, 0);
                 break;
+            case QEMU_OPTION_acpi:
+                acpi_enabled = 1;
+                break;
             }
         }
     }
Index: ioemu/vl.h
===================================================================
--- ioemu.orig/vl.h	2006-08-17 19:49:59.316211597 +0100
+++ ioemu/vl.h	2006-08-17 19:50:02.411869432 +0100
@@ -168,6 +168,7 @@
 extern int kqemu_allowed;
 extern int win2k_install_hack;
 extern int usb_enabled;
+extern int acpi_enabled;
 extern int smp_cpus;
 
 /* XXX: make it dynamic */
@@ -923,6 +924,9 @@
 void piix4_pm_init(PCIBus *bus, int devfn);
 void acpi_bios_init(void);
 
+/* piix4acpi.c */
+extern void pci_piix4_acpi_init(PCIBus *bus, int devfn);
+
 /* pc.c */
 extern QEMUMachine pc_machine;
 extern QEMUMachine isapc_machine;
Index: ioemu/hw/piix_pci.c
===================================================================
--- ioemu.orig/hw/piix_pci.c	2006-08-17 19:38:05.806252180 +0100
+++ ioemu/hw/piix_pci.c	2006-08-17 19:50:02.411869432 +0100
@@ -241,7 +241,7 @@
 static uint32_t pci_bios_io_addr;
 static uint32_t pci_bios_mem_addr;
 /* host irqs corresponding to PCI irqs A-D */
-static uint8_t pci_irqs[4] = { 11, 9, 11, 9 };
+static uint8_t pci_irqs[4] = { 10, 11, 10, 11 };
 
 static void pci_config_writel(PCIDevice *d, uint32_t addr, uint32_t val)
 {
@@ -336,6 +336,14 @@
             pci_set_io_region_addr(d, 3, 0x374);
         }
         break;
+    case 0x0680:
+        if (vendor_id == 0x8086 && device_id == 0x7113) {
+            /* PIIX4 ACPI PM */
+            pci_config_writew(d, 0x20, 0x0000); /* NO smb bus IO enable in PIIX4 */
+            pci_config_writew(d, 0x22, 0x0000);
+            goto default_map;
+        }
+        break;
     case 0x0300:
         if (vendor_id != 0x1234)
             goto default_map;
@@ -386,6 +394,14 @@
         pic_irq = pci_irqs[pin];
         pci_config_writeb(d, PCI_INTERRUPT_LINE, pic_irq);
     }
+
+    if (class== 0x0680&& vendor_id == 0x8086 && device_id == 0x7113) {
+         // PIIX4 ACPI PM
+       pci_config_writew(d, 0x20, 0x0000); // NO smb bus IO enable in PIIX4
+       pci_config_writew(d, 0x22, 0x0000);
+       pci_config_writew(d, 0x3c, 0x0009); // Hardcodeed IRQ9
+       pci_config_writew(d, 0x3d, 0x0001);
+    }
 }
 
 /*
