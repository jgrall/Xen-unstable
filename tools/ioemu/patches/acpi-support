diff -r 2612be97caad Makefile.target
--- a/Makefile.target	Mon Jun 26 16:07:22 2006 +0100
+++ b/Makefile.target	Mon Jun 26 18:38:49 2006 +0100
@@ -335,6 +335,7 @@ VL_OBJS+= ide.o pckbd.o ps2.o vga.o $(SO
 VL_OBJS+= ide.o pckbd.o ps2.o vga.o $(SOUND_HW) dma.o $(AUDIODRV)
 VL_OBJS+= fdc.o mc146818rtc.o serial.o pc.o
 VL_OBJS+= cirrus_vga.o mixeng.o parallel.o
+VL_OBJS+= piix4acpi.o
 DEFINES += -DHAS_AUDIO
 endif
 ifeq ($(TARGET_BASE_ARCH), ppc)
diff -r 2612be97caad hw/pc.c
--- a/hw/pc.c	Mon Jun 26 16:07:22 2006 +0100
+++ b/hw/pc.c	Mon Jun 26 18:38:49 2006 +0100
@@ -566,6 +566,9 @@ static int parallel_io[MAX_PARALLEL_PORT
 static int parallel_io[MAX_PARALLEL_PORTS] = { 0x378, 0x278, 0x3bc };
 static int parallel_irq[MAX_PARALLEL_PORTS] = { 7, 7, 7 };
 
+/* PIIX4 acpi pci configuration space, func 3 */
+extern void pci_piix4_acpi_init(PCIBus *bus);
+
 #ifdef HAS_AUDIO
 static void audio_init (PCIBus *pci_bus)
 {
@@ -867,6 +870,10 @@ static void pc_init1(uint64_t ram_size, 
 
     cmos_init(ram_size, boot_device, bs_table, timeoffset);
 
+    /* using PIIX4 acpi model */
+    if (pci_enabled)
+        pci_piix4_acpi_init(pci_bus);
+
     if (pci_enabled && usb_enabled) {
         usb_uhci_init(pci_bus, usb_root_ports);
         usb_attach(usb_root_ports[0], vm_usb_hub);
diff -r 2612be97caad hw/pci.c
--- a/hw/pci.c	Mon Jun 26 16:07:22 2006 +0100
+++ b/hw/pci.c	Mon Jun 26 18:38:49 2006 +0100
@@ -1697,7 +1697,7 @@ static uint32_t pci_bios_io_addr;
 static uint32_t pci_bios_io_addr;
 static uint32_t pci_bios_mem_addr;
 /* host irqs corresponding to PCI irqs A-D */
-static uint8_t pci_irqs[4] = { 11, 9, 11, 9 };
+static uint8_t pci_irqs[4] = { 10, 11, 10, 11 };
 
 static void pci_set_io_region_addr(PCIDevice *d, int region_num, uint32_t addr)
 {
@@ -1750,12 +1750,22 @@ static void pci_bios_init_device(PCIDevi
             pci_set_io_region_addr(d, 3, 0x374);
         }
         break;
+       case 0x0680:
+       if (vendor_id == 0x8086 && device_id == 0x7113) {
+          // PIIX4 ACPI PM 
+        pci_config_writew(d, 0x20, 0x0000); // NO smb bus IO enable in PIIX4
+        pci_config_writew(d, 0x22, 0x0000); 
+        goto default_map;
+ 	}
+         break;
+
     case 0x0300:
         if (vendor_id != 0x1234)
             goto default_map;
         /* VGA: map frame buffer to default Bochs VBE address */
         pci_set_io_region_addr(d, 0, 0xE0000000);
         break;
+
     case 0x0800:
         /* PIC */
         vendor_id = pci_config_readw(d, PCI_VENDOR_ID);
@@ -1800,6 +1810,13 @@ static void pci_bios_init_device(PCIDevi
         pic_irq = pci_irqs[pin];
         pci_config_writeb(d, PCI_INTERRUPT_LINE, pic_irq);
     }
+    if (class== 0x0680&& vendor_id == 0x8086 && device_id == 0x7113) {
+         // PIIX4 ACPI PM
+       pci_config_writew(d, 0x20, 0x0000); // NO smb bus IO enable in PIIX4
+       pci_config_writew(d, 0x22, 0x0000);
+       pci_config_writew(d, 0x3c, 0x0009); // Hardcodeed IRQ9
+       pci_config_writew(d, 0x3d, 0x0001);
+    }
 }
 
 /*
diff -r 2612be97caad hw/piix4acpi.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/hw/piix4acpi.c	Mon Jun 26 18:38:49 2006 +0100
@@ -0,0 +1,388 @@
+/*
+ * PIIX4 ACPI controller emulation
+ *
+ * Winston liwen Wang, winston.l.wang@intel.com
+ * Copyright (c) 2006 , Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+
+#include "vl.h"
+#define FREQUENCE_PMTIMER  3753425
+/* acpi register bit define here  */
+
+/* PM1_STS 						*/
+#define TMROF_STS 	  (1 << 0)
+#define BM_STS 	  	  (1 << 4)
+#define GBL_STS 	  (1 << 5)
+#define PWRBTN_STS 	  (1 << 8)
+#define RTC_STS 	  (1 << 10)
+#define PRBTNOR_STS       (1 << 11)
+#define WAK_STS 	  (1 << 15)
+/* PM1_EN						*/
+#define TMROF_EN          (1 << 0)
+#define GBL_EN            (1 << 5)
+#define PWRBTN_EN         (1 << 8)
+#define RTC_EN   	  (1 << 10)
+/* PM1_CNT						*/
+#define SCI_EN            (1 << 0)
+#define GBL_RLS           (1 << 2)
+#define SLP_EN   	  (1 << 13)
+
+typedef struct AcpiDeviceState AcpiDeviceState;
+AcpiDeviceState *acpi_device_table;
+
+/* Bits of PM1a register define here  */
+typedef struct PM1Event_BLK {
+    uint16_t pm1_status; /* pm1a_EVT_BLK */
+    uint16_t pm1_enable; /* pm1a_EVT_BLK+2 */
+}PM1Event_BLK;
+
+typedef struct PCIAcpiState {
+    PCIDevice dev;
+    uint16_t irq;
+    uint16_t pm1_status; /* pm1a_EVT_BLK */
+    uint16_t pm1_enable; /* pm1a_EVT_BLK+2 */
+    uint16_t pm1_control; /* pm1a_ECNT_BLK */
+    uint32_t pm1_timer; /* pmtmr_BLK */
+} PCIAcpiState;
+
+static PCIAcpiState *acpi_state;
+
+static inline void acpi_set_irq(PCIAcpiState *s)
+{
+/* no real SCI event need for now, so comment the following line out */
+/*  pic_set_irq(s->irq, 1); */
+    printf("acpi_set_irq: s->irq %x \n",s->irq);
+}
+
+static void acpi_reset(PCIAcpiState *s)
+{
+    uint8_t *pci_conf;
+    pci_conf = s->dev.config;
+
+    pci_conf[0x42] = 0x00;
+    pci_conf[0x43] = 0x00;
+    s->irq = 9;
+    s->pm1_status = 0;
+    s->pm1_enable = 0x00;    /* TMROF_EN should cleared */
+    s->pm1_control = SCI_EN; /* SCI_EN */
+    s->pm1_timer = 0;
+}
+
+/*byte access  */
+static void acpiPm1Status_writeb(void *opaque, uint32_t addr, uint32_t val)
+{
+    PCIAcpiState *s = opaque;
+
+    if ((val&TMROF_STS)==TMROF_STS)
+        s->pm1_status = s->pm1_status&!TMROF_STS;
+
+    if ((val&GBL_STS)==GBL_STS)
+        s->pm1_status = s->pm1_status&!GBL_STS;     
+    
+/*     printf("acpiPm1Status_writeb \n addr %x val:%x pm1_status:%x \n", addr, val,s->pm1_status); */
+}
+
+static uint32_t acpiPm1Status_readb(void *opaque, uint32_t addr)
+{
+    PCIAcpiState *s = opaque;
+    uint32_t val;
+
+    val = s->pm1_status;
+/*         printf("acpiPm1Status_readb \n addr %x val:%x\n", addr, val); */
+
+   return val;
+}
+
+static void acpiPm1StatusP1_writeb(void *opaque, uint32_t addr, uint32_t val)
+{
+    PCIAcpiState *s = opaque;
+
+     s->pm1_status = (val<<8)||(s->pm1_status);
+/*     printf("acpiPm1StatusP1_writeb \n addr %x val:%x\n", addr, val); */
+}
+
+static uint32_t acpiPm1StatusP1_readb(void *opaque, uint32_t addr)
+{
+    PCIAcpiState *s = opaque;
+    uint32_t val;
+
+    val = (s->pm1_status)>>8;
+    printf("acpiPm1StatusP1_readb \n addr %x val:%x\n", addr, val);
+
+    return val;
+}
+
+static void acpiPm1Enable_writeb(void *opaque, uint32_t addr, uint32_t val)
+{
+    PCIAcpiState *s = opaque;
+
+    s->pm1_enable = val;
+/*   printf("acpiPm1Enable_writeb \n addr %x val:%x\n", addr, val); */
+}
+
+static uint32_t acpiPm1Enable_readb(void *opaque, uint32_t addr)
+{
+    PCIAcpiState *s = opaque;
+    uint32_t val;
+
+    val = (s->pm1_enable)||0x1;
+/*  printf("acpiPm1Enable_readb \n addr %x val:%x\n", addr, val); */
+
+    return val;
+}
+
+static void acpiPm1EnableP1_writeb(void *opaque, uint32_t addr, uint32_t val)
+{
+    PCIAcpiState *s = opaque;
+
+    s->pm1_enable = (val<<8)||(s->pm1_enable);
+/*    printf("acpiPm1EnableP1_writeb \n addr %x val:%x\n", addr, val); */
+
+}
+
+static uint32_t acpiPm1EnableP1_readb(void *opaque, uint32_t addr)
+{
+    PCIAcpiState *s = opaque;
+    uint32_t val;
+
+    val = (s->pm1_enable)>>8;
+/*  printf("acpiPm1EnableP1_readb \n addr %x val:%x\n", addr, val); */
+
+    return val;
+}
+
+static void acpiPm1Control_writeb(void *opaque, uint32_t addr, uint32_t val)
+{
+    PCIAcpiState *s = opaque;
+
+    s->pm1_control = val;
+/*  printf("acpiPm1Control_writeb \n addr %x val:%x\n", addr, val); */
+
+}
+
+static uint32_t acpiPm1Control_readb(void *opaque, uint32_t addr)
+{
+    PCIAcpiState *s = opaque;
+    uint32_t val;
+
+    val = s->pm1_control;
+/*    printf("acpiPm1Control_readb \n addr %x val:%x\n", addr, val); */
+
+    return val;
+}
+
+static void acpiPm1ControlP1_writeb(void *opaque, uint32_t addr, uint32_t val)
+{
+    PCIAcpiState *s = opaque;
+
+    s->pm1_control = (val<<8)||(s->pm1_control);
+/*    printf("acpiPm1ControlP1_writeb \n addr %x val:%x\n", addr, val); */
+
+} 
+
+static uint32_t acpiPm1ControlP1_readb(void *opaque, uint32_t addr)
+{
+    PCIAcpiState *s = opaque;
+    uint32_t val;
+
+    val = (s->pm1_control)>>8;
+/*    printf("acpiPm1ControlP1_readb \n addr %x val:%x\n", addr, val); */
+
+    return val;
+}
+
+
+/* word access   */
+
+static void acpiPm1Status_writew(void *opaque, uint32_t addr, uint32_t val)
+{
+    PCIAcpiState *s = opaque;
+
+    if ((val&TMROF_STS)==TMROF_STS)
+        s->pm1_status = s->pm1_status&!TMROF_STS;
+
+    if ((val&GBL_STS)==GBL_STS)
+        s->pm1_status = s->pm1_status&!GBL_STS;     
+
+/*    printf("acpiPm1Status_writew \n addr %x val:%x pm1_status:%x \n", addr, val,s->pm1_status); */
+}
+
+static uint32_t acpiPm1Status_readw(void *opaque, uint32_t addr)
+{
+    PCIAcpiState *s = opaque;
+    uint32_t val;
+
+    val = s->pm1_status;
+/*    printf("acpiPm1Status_readw \n addr %x val:%x\n", addr, val); */
+
+    return val;
+}
+
+static void acpiPm1Enable_writew(void *opaque, uint32_t addr, uint32_t val)
+{
+    PCIAcpiState *s = opaque;
+
+    s->pm1_enable = val;
+/*    printf("acpiPm1Enable_writew \n addr %x val:%x\n", addr, val); */
+
+}
+
+static uint32_t acpiPm1Enable_readw(void *opaque, uint32_t addr)
+{
+    PCIAcpiState *s = opaque;
+    uint32_t val;
+
+    val = s->pm1_enable;
+/*    printf("acpiPm1Enable_readw \n addr %x val:%x\n", addr, val); */
+
+   return val;
+}
+
+static void acpiPm1Control_writew(void *opaque, uint32_t addr, uint32_t val)
+{
+    PCIAcpiState *s = opaque;
+
+    s->pm1_control = val;
+/*    printf("acpiPm1Control_writew \n addr %x val:%x\n", addr, val); */
+
+} 
+
+static uint32_t acpiPm1Control_readw(void *opaque, uint32_t addr)
+{
+    PCIAcpiState *s = opaque;
+    uint32_t val;
+
+    val = s->pm1_control;
+/*    printf("acpiPm1Control_readw \n addr %x val:%x\n", addr, val);  */
+
+    return val;
+}
+
+/* dword access */
+
+static void acpiPm1Event_writel(void *opaque, uint32_t addr, uint32_t val)
+{
+    PCIAcpiState *s = opaque;
+
+    s->pm1_status = val;
+    s->pm1_enable = val>>16;
+/*     printf("acpiPm1Event_writel \n addr %x val:%x \n", addr, val); */
+
+}
+
+static void acpiPm1Event_readl(void *opaque, uint32_t addr)
+{
+    PCIAcpiState *s = opaque;
+    uint32_t val;
+
+    val=s->pm1_status|(s->pm1_enable<<16);
+/*    printf("acpiPm1Event_readl \n addr %x val:%x\n", addr, val);    */
+}
+
+static void acpiPm1Timer_writel(void *opaque, uint32_t addr, uint32_t val)
+{
+    PCIAcpiState *s = opaque;
+
+    s->pm1_timer = val;
+/*    printf("acpiPm1Timer_writel \n addr %x val:%x\n", addr, val); */
+}
+
+static uint32_t acpiPm1Timer_readl(void *opaque, uint32_t addr)
+{
+    PCIAcpiState *s = opaque;
+    uint32_t val;
+
+    val = s->pm1_timer;
+/*    printf("acpiPm1Timer_readl \n addr %x val:%x\n", addr, val); */
+    return val;
+}
+
+static void acpi_map(PCIDevice *pci_dev, int region_num,
+                    uint32_t addr, uint32_t size, int type)
+{
+    PCIAcpiState *d = (PCIAcpiState *)pci_dev;
+
+    printf("register acpi io \n");
+
+    /* Byte access */
+    register_ioport_write(addr, 1, 1, acpiPm1Status_writeb, d);
+    register_ioport_read(addr, 1, 1, acpiPm1Status_readb, d);
+    register_ioport_write(addr+1, 1, 1, acpiPm1StatusP1_writeb, d);
+    register_ioport_read(addr+1, 1, 1, acpiPm1StatusP1_readb, d);
+
+    register_ioport_write(addr + 2, 1, 1, acpiPm1Enable_writeb, d);
+    register_ioport_read(addr + 2, 1, 1, acpiPm1Enable_readb, d);
+    register_ioport_write(addr + 2 +1, 1, 1, acpiPm1EnableP1_writeb, d);
+    register_ioport_read(addr + 2 +1, 1, 1, acpiPm1EnableP1_readb, d);
+
+    register_ioport_write(addr + 4, 1, 1, acpiPm1Control_writeb, d);
+    register_ioport_read(addr + 4, 1, 1, acpiPm1Control_readb, d);
+    register_ioport_write(addr + 4 + 1, 1, 1, acpiPm1ControlP1_writeb, d);
+    register_ioport_read(addr + 4 +1, 1, 1, acpiPm1ControlP1_readb, d);	
+
+    /* Word access */
+    register_ioport_write(addr, 2, 2, acpiPm1Status_writew, d);
+    register_ioport_read(addr, 2, 2, acpiPm1Status_readw, d);
+
+    register_ioport_write(addr + 2, 2, 2, acpiPm1Enable_writew, d);
+    register_ioport_read(addr + 2, 2, 2, acpiPm1Enable_readw, d); 
+
+    register_ioport_write(addr + 4, 2, 2, acpiPm1Control_writew, d);
+    register_ioport_read(addr + 4, 2, 2, acpiPm1Control_readw, d);
+
+    /* DWord access */
+    register_ioport_write(addr, 4, 4, acpiPm1Event_writel, d);
+    register_ioport_read(addr, 4, 4, acpiPm1Event_readl, d);
+		
+    register_ioport_write(addr + 8, 4, 4, acpiPm1Timer_writel, d);
+    register_ioport_read(addr + 8, 4, 4, acpiPm1Timer_readl, d);
+}
+													
+
+/* PIIX4 acpi pci configuration space, func 3 */
+void pci_piix4_acpi_init(PCIBus *bus)
+{
+    PCIAcpiState *d;
+    uint8_t *pci_conf;
+
+    /* register a function 3 of PIIX4 */
+    d = (PCIAcpiState *)pci_register_device(
+        bus, "PIIX4 ACPI", sizeof(PCIAcpiState),
+        ((PCIDevice *)piix3_state)->devfn + 3, NULL, NULL);
+
+    acpi_state = d;
+    pci_conf = d->dev.config;
+    pci_conf[0x00] = 0x86;  /* Intel */
+    pci_conf[0x01] = 0x80;
+    pci_conf[0x02] = 0x13;
+    pci_conf[0x03] = 0x71;
+    pci_conf[0x08] = 0x01;  /* B0 stepping */
+    pci_conf[0x09] = 0x00;  /* base class */
+    pci_conf[0x0a] = 0x80;  /* Sub class */
+    pci_conf[0x0b] = 0x06;
+    pci_conf[0x0e] = 0x00;
+    pci_conf[0x3d] = 0x01;  /* Hardwired to PIRQA is used */
+
+    pci_register_io_region((PCIDevice *)d, 4, 0x10,
+                           PCI_ADDRESS_SPACE_IO, acpi_map);
+
+    acpi_reset (d);
+}
