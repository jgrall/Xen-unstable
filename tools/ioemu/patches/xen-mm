diff -r f36cde91babe hw/pc.c
--- a/hw/pc.c	Mon Jun 26 15:16:50 2006 +0100
+++ b/hw/pc.c	Mon Jun 26 15:18:19 2006 +0100
@@ -639,7 +639,9 @@ static void pc_init1(uint64_t ram_size, 
     }
 
     /* allocate RAM */
+#ifndef CONFIG_DM		/* HVM domain owns memory */
     cpu_register_physical_memory(0, ram_size, 0);
+#endif
 
     /* BIOS load */
     bios_offset = ram_size + vga_ram_size;
@@ -671,8 +673,10 @@ static void pc_init1(uint64_t ram_size, 
     ret = load_image(buf, phys_ram_base + vga_bios_offset);
     
     /* setup basic memory access */
+#ifndef CONFIG_DM		/* HVM domain owns memory */
     cpu_register_physical_memory(0xc0000, 0x10000, 
                                  vga_bios_offset | IO_MEM_ROM);
+#endif
 
     /* map the last 128KB of the BIOS in ISA space */
     isa_bios_size = bios_size;
diff -r f36cde91babe vl.c
--- a/vl.c	Mon Jun 26 15:16:50 2006 +0100
+++ b/vl.c	Mon Jun 26 15:18:19 2006 +0100
@@ -158,6 +158,8 @@ int vnc_display = -1;
 #else
 #define MAX_CPUS 1
 #endif
+
+int xc_handle;
 
 char domain_name[1024] = { 'H','V', 'M', 'X', 'E', 'N', '-'};
 extern int domid;
@@ -5105,6 +5107,9 @@ int main(int argc, char **argv)
     QEMUMachine *machine;
     char usb_devices[MAX_VM_USB_PORTS][128];
     int usb_devices_index;
+    unsigned long nr_pages;
+    xen_pfn_t *page_array;
+    extern void *shared_page;
 
     char qemu_dm_logfilename[64];
 
@@ -5341,11 +5346,13 @@ int main(int argc, char **argv)
                 ram_size = atol(optarg) * 1024 * 1024;
                 if (ram_size <= 0)
                     help();
+#ifndef CONFIG_DM
                 if (ram_size > PHYS_RAM_MAX_SIZE) {
                     fprintf(stderr, "qemu: at most %d MB RAM can be simulated\n",
                             PHYS_RAM_MAX_SIZE / (1024 * 1024));
                     exit(1);
                 }
+#endif /* !CONFIG_DM */
                 break;
             case QEMU_OPTION_l:
                 {
@@ -5557,6 +5564,39 @@ int main(int argc, char **argv)
     /* init the memory */
     phys_ram_size = ram_size + vga_ram_size + bios_size;
 
+#ifdef CONFIG_DM
+
+    nr_pages = ram_size/PAGE_SIZE;
+    xc_handle = xc_interface_open();
+
+    page_array = (xen_pfn_t *)malloc(nr_pages * sizeof(xen_pfn_t));
+    if (page_array == NULL) {
+        fprintf(logfile, "malloc returned error %d\n", errno);
+        exit(-1);
+    }
+
+    if (xc_get_pfn_list(xc_handle, domid, page_array, nr_pages) != nr_pages) {
+        fprintf(logfile, "xc_get_pfn_list returned error %d\n", errno);
+        exit(-1);
+    }
+
+    phys_ram_base = xc_map_foreign_batch(xc_handle, domid,
+                                         PROT_READ|PROT_WRITE, page_array,
+                                         nr_pages - 1);
+    if (phys_ram_base == 0) {
+        fprintf(logfile, "xc_map_foreign_batch returned error %d\n", errno);
+        exit(-1);
+    }
+
+    shared_page = xc_map_foreign_range(xc_handle, domid, PAGE_SIZE,
+                                       PROT_READ|PROT_WRITE,
+                                       page_array[nr_pages - 1]);
+
+    fprintf(logfile, "shared page at pfn:%lx, mfn: %"PRIx64"\n", nr_pages - 1,
+            (uint64_t)(page_array[nr_pages - 1]));
+
+#else  /* !CONFIG_DM */
+
 #ifdef CONFIG_SOFTMMU
     phys_ram_base = qemu_vmalloc(phys_ram_size);
     if (!phys_ram_base) {
@@ -5596,6 +5636,8 @@ int main(int argc, char **argv)
         }
     }
 #endif
+
+#endif /* !CONFIG_DM */
 
     /* we always create the cdrom drive, even if no disk is there */
     bdrv_init();
