diff -uprN tpm_emulator-0.3-x86_64/AUTHORS tpm_emulator/AUTHORS
--- tpm_emulator-0.3-x86_64/AUTHORS	2006-08-29 15:07:21.618299064 -0700
+++ tpm_emulator/AUTHORS	2006-08-29 15:26:17.099679656 -0700
@@ -1,2 +1,3 @@
 Mario Strasser <mast@gmx.net>
 Heiko Stamer <stamer@gaos.org> [DAA]
+INTEL Corp <> [Dropped to Ring3]
diff -uprN tpm_emulator-0.3-x86_64/ChangeLog tpm_emulator/ChangeLog
--- tpm_emulator-0.3-x86_64/ChangeLog	2006-08-29 15:07:21.618299064 -0700
+++ tpm_emulator/ChangeLog	2006-08-29 15:26:17.100679504 -0700
@@ -1,3 +1,6 @@
+2005-08-16 Intel Corp
+	* Moved module out of kernel to run as a ring 3 app
+
 2005-12-24  Mario Strasser <mast@gmx.net>
 	* tpm_transport.c, tpm_marshalling.c, tpm_structures.h:
 		Transport session functionality added
diff -uprN tpm_emulator-0.3-x86_64/Makefile tpm_emulator/Makefile
--- tpm_emulator-0.3-x86_64/Makefile	2006-08-29 15:08:20.532342768 -0700
+++ tpm_emulator/Makefile	2006-08-29 15:27:39.559143912 -0700
@@ -1,22 +1,31 @@
 # Software-Based Trusted Platform Module (TPM) Emulator for Linux
 # Copyright (C) 2004 Mario Strasser <mast@gmx.net>
+# Copyright (C) 2006 INTEL Corp.
 #
 # $Id: Makefile 69 2005-12-13 12:55:52Z mast $
 
-# kernel settings
-KERNEL_RELEASE := $(shell uname -r)
-KERNEL_BUILD   := /lib/modules/$(KERNEL_RELEASE)/build
-MOD_SUBDIR     := misc
 COMPILE_ARCH    ?= $(shell uname -m | sed -e s/i.86/x86_32/)
 
 # module settings
-MODULE_NAME    := tpm_emulator
+BIN            := tpm_emulator
 VERSION_MAJOR  := 0
 VERSION_MINOR  := 3
 VERSION_BUILD  := $(shell date +"%s")
 
-# enable/disable DEBUG messages
-EXTRA_CFLAGS   += -Wall -DDEBUG -g  
+# Installation program and options
+INSTALL         = install
+INSTALL_PROG    = $(INSTALL) -m0755
+INSTALL_DIR     = $(INSTALL) -d -m0755
+
+# Xen tools installation directory
+TOOLS_INSTALL_DIR = $(DESTDIR)/usr/bin
+
+CC      := gcc
+CFLAGS  += -g -Wall $(INCLUDE) -DDEBUG
+CFLAGS  += -I. -Itpm
+
+# Is the simulator running in it's own vm?
+#CFLAGS += -DVTPM_MULTI_VM
 
 ifeq ($(COMPILE_ARCH),x86_64)
 LIBDIR = lib64
@@ -34,38 +43,31 @@ DIRS           := . crypto tpm 
 SRCS           := $(foreach dir, $(DIRS), $(wildcard $(src)/$(dir)/*.c))
 OBJS           := $(patsubst %.c, %.o, $(SRCS))
 SRCS           += $(foreach dir, $(DIRS), $(wildcard $(src)/$(dir)/*.h))
-DISTSRC        := ./README ./AUTHORS ./ChangeLog ./Makefile $(SRCS)
-DISTDIR        := tpm_emulator-$(VERSION_MAJOR).$(VERSION_MINOR)
 
-obj-m               := $(MODULE_NAME).o
-$(MODULE_NAME)-objs := $(patsubst $(src)/%.o, %.o, $(OBJS)) crypto/libgmp.a
+obj-m               := $(BIN)
+$(BIN)-objs := $(patsubst $(src)/%.o, %.o, $(OBJS)) crypto/libgmp.a
 
 EXTRA_CFLAGS   += -I$(src) -I$(src)/crypto -I$(src)/tpm 
 
 # do not print "Entering directory ..."
 MAKEFLAGS      += --no-print-directory
 
-all:	$(src)/crypto/gmp.h $(src)/crypto/libgmp.a version
-	@$(MAKE) -C $(KERNEL_BUILD) M=$(CURDIR) modules
+all: $(BIN)
+
+$(BIN):	$(src)/crypto/gmp.h $(src)/crypto/libgmp.a version $(SRCS) $(OBJS)
+	$(CC) $(CFLAGS) $(OBJS) $(src)/crypto/libgmp.a -o $(BIN)
+
+%.o: %.c
+	$(CC) $(CFLAGS) -c $< -o $@
 
-install:
-	@$(MAKE) -C $(KERNEL_BUILD) M=$(CURDIR) modules_install
-	test -d /var/tpm || mkdir /var/tpm
-	test -c /dev/tpm || mknod /dev/tpm c 10 224
-	chmod 666 /dev/tpm
-	depmod -a
+install: $(BIN)
+	$(INSTALL_PROG) $(BIN) $(TOOLS_INSTALL_DIR)
 
 clean:
-	@$(MAKE) -C $(KERNEL_BUILD) M=$(CURDIR) clean
-	rm -f $(src)/crypto/gmp.h $(src)/crypto/libgmp.a
+	rm -f $(src)/crypto/gmp.h $(src)/crypto/libgmp.a $(OBJS)
 
-dist:	$(DISTSRC)
-	rm -rf $(DISTDIR)
-	mkdir $(DISTDIR)
-	cp --parents $(DISTSRC) $(DISTDIR)/
-	rm -f $(DISTDIR)/crypto/gmp.h 
-	tar -chzf $(DISTDIR).tar.gz $(DISTDIR)
-	rm -rf $(DISTDIR)
+mrproper: clean
+	rm -f $(BIN) tpm_version.h
 
 $(src)/crypto/libgmp.a:
 	test -f $(src)/crypto/libgmp.a || ln -s $(GMP_LIB) $(src)/crypto/libgmp.a
diff -uprN tpm_emulator-0.3-x86_64/README tpm_emulator/README
--- tpm_emulator-0.3-x86_64/README	2006-08-29 15:07:43.530967832 -0700
+++ tpm_emulator/README	2006-08-29 15:26:17.105678744 -0700
@@ -13,7 +13,8 @@ $Id: README 78 2006-01-07 10:45:39Z mast
 Copyright
 --------------------------------------------------------------------------
 Copyright (C) 2004 Mario Strasser <mast@gmx.net> and Swiss Federal 
-Institute of Technology (ETH) Zurich.
+                   Institute of Technology (ETH) Zurich.
+Copyright (C) 2005 INTEL Corp 
               
 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
diff -uprN tpm_emulator-0.3-x86_64/README.1st tpm_emulator/README.1st
--- tpm_emulator-0.3-x86_64/README.1st	1969-12-31 16:00:00.000000000 -0800
+++ tpm_emulator/README.1st	2006-08-29 15:26:17.105678744 -0700
@@ -0,0 +1 @@
+Note that you must manually create /tmp/tpm_in.fifo and /tmp/tpm_out.fifo for this emulator to work.
diff -uprN tpm_emulator-0.3-x86_64/crypto/gmp_kernel_wrapper.c tpm_emulator/crypto/gmp_kernel_wrapper.c
--- tpm_emulator-0.3-x86_64/crypto/gmp_kernel_wrapper.c	2006-08-29 15:07:43.525968592 -0700
+++ tpm_emulator/crypto/gmp_kernel_wrapper.c	2006-08-29 15:26:17.101679352 -0700
@@ -1,5 +1,6 @@
 /* Software-Based Trusted Platform Module (TPM) Emulator for Linux
  * Copyright (C) 2004 Mario Strasser <mast@gmx.net>,
+ * Copyright (C) 2005 INTEL Corp
  *
  * This module is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published
@@ -24,15 +25,10 @@ int __gmp_junk;
 void __attribute__ ((regparm(0))) __gmp_assert_fail(const char *filename, 
   int linenum, const char *expr) 
 {
-  panic(KERN_CRIT TPM_MODULE_NAME "%s:%d: GNU MP assertion failed: %s\n", 
+  error("%s:%d: GNU MP assertion failed: %s\n", 
     filename, linenum, expr);
 }
 
-void __attribute__ ((regparm(0))) abort(void)
-{
-  panic(KERN_CRIT TPM_MODULE_NAME "GNU MP abort() was called\n");
-}
-
 /* overwrite GNU MP random functions (used by mpz/millerrabin.c) */ 
 
 void __attribute__ ((regparm(0))) gmp_randinit(gmp_randstate_t rstate, 
@@ -77,20 +73,19 @@ void __attribute__ ((regparm(0))) mpz_ur
 
 void __attribute__ ((regparm(0))) *kernel_allocate(size_t size)
 {
-  void *ret  = (void*)kmalloc(size, GFP_KERNEL);
-  if (!ret) panic(KERN_CRIT TPM_MODULE_NAME 
-    "GMP: cannot allocate memory (size=%Zu)\n", size);
+  void *ret  = (void*)malloc(size);
+  if (!ret) error("GMP: cannot allocate memory (size=%Zu)\n", size);
   return ret;
 }
 
 void __attribute__ ((regparm(0))) *kernel_reallocate(void *oldptr, 
   size_t old_size, size_t new_size)
 {
-  void *ret = (void*)kmalloc(new_size, GFP_KERNEL);
-  if (!ret) panic(KERN_CRIT TPM_MODULE_NAME "GMP: Cannot reallocate memory "
+  void *ret = (void*)malloc(new_size);
+  if (!ret) error("GMP: Cannot reallocate memory "
     "(old_size=%Zu new_size=%Zu)\n", old_size, new_size);
   memcpy(ret, oldptr, old_size);
-  kfree(oldptr);
+  free(oldptr);
   return ret;
 }
 
@@ -99,7 +94,7 @@ void __attribute__ ((regparm(0))) kernel
   /* overwrite used memory */
   if (blk_ptr != NULL) { 
     memset(blk_ptr, 0, blk_size);
-    kfree(blk_ptr);
+    free(blk_ptr);
   }
 }
 
diff -uprN tpm_emulator-0.3-x86_64/crypto/rsa.c tpm_emulator/crypto/rsa.c
--- tpm_emulator-0.3-x86_64/crypto/rsa.c	2006-08-29 15:07:21.618299064 -0700
+++ tpm_emulator/crypto/rsa.c	2006-08-29 15:26:17.102679200 -0700
@@ -1,5 +1,6 @@
 /* Software-Based Trusted Platform Module (TPM) Emulator for Linux
  * Copyright (C) 2004 Mario Strasser <mast@gmx.net>,
+ * Copyright (C) 2005 INTEL Corp
  *
  * This module is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published
@@ -381,7 +382,7 @@ static int encode_message(int type, uint
       msg[0] = 0x00;
       get_random_bytes(&msg[1], SHA1_DIGEST_LENGTH);
       sha1_init(&ctx);
-      sha1_update(&ctx, "TCPA", 4);
+      sha1_update(&ctx, (uint8_t *) "TCPA", 4);
       sha1_final(&ctx, &msg[1 + SHA1_DIGEST_LENGTH]);
       memset(&msg[1 + 2 * SHA1_DIGEST_LENGTH], 0x00, 
         msg_len - data_len - 2 * SHA1_DIGEST_LENGTH - 2);
@@ -429,7 +430,7 @@ static int decode_message(int type, uint
       mask_generation(&msg[1], SHA1_DIGEST_LENGTH,
         &msg[1 + SHA1_DIGEST_LENGTH], msg_len - SHA1_DIGEST_LENGTH - 1);
       sha1_init(&ctx);
-      sha1_update(&ctx, "TCPA", 4);
+      sha1_update(&ctx, (uint8_t *) "TCPA", 4);
       sha1_final(&ctx, &msg[1]);
       if (memcmp(&msg[1], &msg[1 + SHA1_DIGEST_LENGTH], 
           SHA1_DIGEST_LENGTH) != 0) return -1;
diff -uprN tpm_emulator-0.3-x86_64/linux_module.c tpm_emulator/linux_module.c
--- tpm_emulator-0.3-x86_64/linux_module.c	2006-08-29 15:07:43.526968440 -0700
+++ tpm_emulator/linux_module.c	1969-12-31 16:00:00.000000000 -0800
@@ -1,194 +0,0 @@
-/* Software-Based Trusted Platform Module (TPM) Emulator for Linux 
- * Copyright (C) 2004 Mario Strasser <mast@gmx.net>,
- *
- * This module is free software; you can redistribute it and/or modify 
- * it under the terms of the GNU General Public License as published 
- * by the Free Software Foundation; either version 2 of the License, 
- * or (at your option) any later version.  
- *
- * This module is distributed in the hope that it will be useful, 
- * but WITHOUT ANY WARRANTY; without even the implied warranty of 
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the 
- * GNU General Public License for more details.
- *
- * $Id: linux_module.c 76 2006-01-02 22:17:58Z hstamer $
- */
-
-#include <linux/module.h>
-#include <linux/kernel.h>
-#include <linux/init.h>
-#include <linux/miscdevice.h>
-#include <linux/poll.h>
-#include "linux_module.h"
-#include "tpm/tpm_emulator.h"
-
-MODULE_LICENSE("GPL");
-MODULE_AUTHOR("Mario Strasser <mast@gmx.net>");
-MODULE_DESCRIPTION("Trusted Platform Module (TPM) Emulator");
-MODULE_SUPPORTED_DEVICE(TPM_DEVICE_NAME);
-
-/* module startup parameters */
-char *startup = "save";
-module_param(startup, charp, 0444);
-MODULE_PARM_DESC(startup, " Sets the startup mode of the TPM. "
-  "Possible values are 'clear', 'save' (default) and 'deactivated.");
-char *storage_file = "/var/tpm/tpm_emulator-1.2.0.2";
-module_param(storage_file, charp, 0644);
-MODULE_PARM_DESC(storage_file, " Sets the persistent-data storage " 
-  "file of the TPM.");
-
-/* TPM lock */
-static struct semaphore tpm_mutex;
-
-/* TPM command response */
-static struct {
-  uint8_t *data;
-  uint32_t size;
-} tpm_response;
-
-/* module state */
-#define STATE_IS_OPEN 0
-static uint32_t module_state;
-
-static int tpm_open(struct inode *inode, struct file *file)
-{
-  debug("%s()", __FUNCTION__);
-  if (test_and_set_bit(STATE_IS_OPEN, (void*)&module_state)) return -EBUSY;
-  return 0;
-}
-
-static int tpm_release(struct inode *inode, struct file *file)
-{
-  debug("%s()", __FUNCTION__);
-  clear_bit(STATE_IS_OPEN, (void*)&module_state);
-  down(&tpm_mutex);
-  if (tpm_response.data != NULL) {
-    kfree(tpm_response.data);
-    tpm_response.data = NULL;
-  }
-  up(&tpm_mutex);
-  return 0;
-}
-
-static ssize_t tpm_read(struct file *file, char *buf, size_t count, loff_t *ppos)
-{
-  debug("%s(%Zu)", __FUNCTION__, count);
-  down(&tpm_mutex);
-  if (tpm_response.data != NULL) {
-    count = min(count, (size_t)tpm_response.size - (size_t)*ppos);
-    count -= copy_to_user(buf, &tpm_response.data[*ppos], count);
-    *ppos += count;
-    if ((size_t)tpm_response.size == (size_t)*ppos) {
-      kfree(tpm_response.data);
-      tpm_response.data = NULL;
-    }
-  } else {
-    count = 0;
-  }
-  up(&tpm_mutex);
-  return count;
-}
-
-static ssize_t tpm_write(struct file *file, const char *buf, size_t count, loff_t *ppos)
-{
-  debug("%s(%Zu)", __FUNCTION__, count);
-  down(&tpm_mutex);
-  *ppos = 0;
-  if (tpm_response.data != NULL) kfree(tpm_response.data);
-  if (tpm_handle_command(buf, count, &tpm_response.data, 
-                         &tpm_response.size) != 0) { 
-    count = -EILSEQ;
-    tpm_response.data = NULL;
-  }
-  up(&tpm_mutex);
-  return count;
-}
-
-#define TPMIOC_CANCEL   _IO('T', 0x00)
-#define TPMIOC_TRANSMIT _IO('T', 0x01)
-
-static int tpm_ioctl(struct inode *inode, struct file *file, unsigned int cmd, unsigned long arg)
-{
-  debug("%s(%d, %p)", __FUNCTION__, cmd, (char*)arg);
-  if (cmd == TPMIOC_TRANSMIT) {
-    uint32_t count = ntohl(*(uint32_t*)(arg + 2));
-    down(&tpm_mutex);
-    if (tpm_response.data != NULL) kfree(tpm_response.data);
-    if (tpm_handle_command((char*)arg, count, &tpm_response.data,
-                           &tpm_response.size) == 0) {
-      tpm_response.size -= copy_to_user((char*)arg, tpm_response.data,
-                            tpm_response.size);
-      kfree(tpm_response.data);
-      tpm_response.data = NULL;
-    } else {
-      tpm_response.size = 0;
-      tpm_response.data = NULL;
-    }
-    up(&tpm_mutex);
-    return tpm_response.size;
-  }
-  return -1;
-}
-
-struct file_operations fops = {
-  .owner   = THIS_MODULE,
-  .open    = tpm_open,
-  .release = tpm_release,
-  .read    = tpm_read,
-  .write   = tpm_write,
-  .ioctl   = tpm_ioctl,
-};
-
-static struct miscdevice tpm_dev = {
-  .minor      = TPM_DEVICE_MINOR, 
-  .name       = TPM_DEVICE_NAME, 
-  .fops       = &fops,
-};
-
-int __init init_tpm_module(void)
-{
-  int res = misc_register(&tpm_dev);
-  if (res != 0) {
-    error("misc_register() failed for minor %d\n", TPM_DEVICE_MINOR);
-    return res;
-  }
-  /* initialize variables */
-  sema_init(&tpm_mutex, 1);
-  module_state = 0;
-  tpm_response.data = NULL;    
-  /* initialize TPM emulator */
-  if (!strcmp(startup, "clear")) {
-    tpm_emulator_init(1);
-  } else if (!strcmp(startup, "save")) {
-    tpm_emulator_init(2);
-  } else if (!strcmp(startup, "deactivated")) {
-    tpm_emulator_init(3);
-  } else {
-    error("invalid startup mode '%s'; must be 'clear', "
-      "'save' (default) or 'deactivated", startup);
-    misc_deregister(&tpm_dev);
-    return -EINVAL;
-  }
-  return 0;
-}
-
-void __exit cleanup_tpm_module(void)
-{
-  tpm_emulator_shutdown();
-  misc_deregister(&tpm_dev);
-  if (tpm_response.data != NULL) kfree(tpm_response.data);
-}
-
-module_init(init_tpm_module);
-module_exit(cleanup_tpm_module);
-
-uint64_t tpm_get_ticks(void)
-{
-  static struct timespec old_time = {0, 0};
-  struct timespec new_time = current_kernel_time();
-  uint64_t ticks = (uint64_t)(old_time.tv_sec - new_time.tv_sec) * 1000000
-                   + (old_time.tv_nsec - new_time.tv_nsec) / 1000;
-  old_time = new_time;
-  return (ticks > 0) ? ticks : 1;
-}
-
diff -uprN tpm_emulator-0.3-x86_64/linux_module.h tpm_emulator/linux_module.h
--- tpm_emulator-0.3-x86_64/linux_module.h	2006-08-29 15:07:43.527968288 -0700
+++ tpm_emulator/linux_module.h	2006-08-29 15:26:17.103679048 -0700
@@ -1,5 +1,6 @@
 /* Software-Based Trusted Platform Module (TPM) Emulator for Linux
  * Copyright (C) 2004 Mario Strasser <mast@gmx.net>,
+ * Copyright (C) 2005 INTEL Corp
  *
  * This module is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published
@@ -17,17 +18,22 @@
 #ifndef _LINUX_MODULE_H_
 #define _LINUX_MODULE_H_
 
-#include <linux/version.h>
-#include <linux/kernel.h>
-#include <linux/slab.h>
+#include <malloc.h>
+#include <stdint.h>
+#include <stdio.h>
+#include <string.h>
 #include <linux/types.h>
-#include <linux/string.h>
-#include <linux/random.h>
-#include <linux/time.h>
-#include <asm/byteorder.h>
 
-/* module settings */
+#include <endian.h>
+#define __BYTEORDER_HAS_U64__
+#ifdef LITTLE_ENDIAN
+ #include <linux/byteorder/little_endian.h>
+#else
+ #include <linux/byteorder/big_endian.h>
+#endif
 
+/* module settings */
+#define min(A,B) ((A)<(B)?(A):(B))
 #ifndef STR
 #define STR(s) __STR__(s)
 #define __STR__(s) #s
@@ -38,35 +44,36 @@
 #define TPM_DEVICE_NAME         "tpm"
 #define TPM_MODULE_NAME 	"tpm_emulator"
 
-/* debug and log output functions */
-
 #ifdef DEBUG
-#define debug(fmt, ...) printk(KERN_DEBUG "%s %s:%d: Debug: " fmt "\n", \
-                        TPM_MODULE_NAME, __FILE__, __LINE__, ## __VA_ARGS__)
+#define debug(fmt, ...) printf("TPMD: %s:%d: Debug: " fmt "\n", \
+                        __FILE__, __LINE__, ## __VA_ARGS__)
 #else
 #define debug(fmt, ...) 
 #endif
-#define info(fmt, ...)  printk(KERN_INFO "%s %s:%d: Info: " fmt "\n", \
-                        TPM_MODULE_NAME, __FILE__, __LINE__, ## __VA_ARGS__)
-#define error(fmt, ...) printk(KERN_ERR "%s %s:%d: Error: " fmt "\n", \
-                        TPM_MODULE_NAME, __FILE__, __LINE__, ## __VA_ARGS__)
-#define alert(fmt, ...) printk(KERN_ALERT "%s %s:%d: Alert: " fmt "\n", \
-                        TPM_MODULE_NAME, __FILE__, __LINE__, ## __VA_ARGS__)
+#define info(fmt, ...)  printf("TPMD: %s:%d: Info: " fmt "\n", \
+                        __FILE__, __LINE__, ## __VA_ARGS__)
+#define error(fmt, ...) printf("TPMD: %s:%d: Error: " fmt "\n", \
+                        __FILE__, __LINE__, ## __VA_ARGS__)
+#define alert(fmt, ...) printf("TPMD: %s:%d: Alert: " fmt "\n", \
+                        __FILE__, __LINE__, ## __VA_ARGS__)
 
 /* memory allocation */
 
 static inline void *tpm_malloc(size_t size) 
 {
-  return kmalloc(size, GFP_KERNEL);  
+  return malloc(size);  
 }
 
 static inline void tpm_free(const void *ptr)
 {
-  if (ptr != NULL) kfree(ptr);
+  if (ptr != NULL) free( (void *) ptr);
 }
 
 /* random numbers */
 
+//FIXME;
+void get_random_bytes(void *buf, int nbytes);
+
 static inline void tpm_get_random_bytes(void *buf, int nbytes)
 {
   get_random_bytes(buf, nbytes);
@@ -86,9 +93,9 @@ uint64_t tpm_get_ticks(void);
 #define CPU_TO_LE16(x) __cpu_to_le16(x)
 
 #define BE64_TO_CPU(x) __be64_to_cpu(x)
-#define LE64_TO_CPU(x) __be64_to_cpu(x)
+#define LE64_TO_CPU(x) __le64_to_cpu(x)
 #define BE32_TO_CPU(x) __be32_to_cpu(x)
-#define LE32_TO_CPU(x) __be32_to_cpu(x)
+#define LE32_TO_CPU(x) __le32_to_cpu(x)
 #define BE16_TO_CPU(x) __be16_to_cpu(x)
 #define LE16_TO_CPU(x) __le16_to_cpu(x)
 
diff -uprN tpm_emulator-0.3-x86_64/tpm/tpm_audit.c tpm_emulator/tpm/tpm_audit.c
--- tpm_emulator-0.3-x86_64/tpm/tpm_audit.c	2006-08-29 15:07:21.620298760 -0700
+++ tpm_emulator/tpm/tpm_audit.c	2006-08-29 15:26:17.107678440 -0700
@@ -1,6 +1,7 @@
 /* Software-Based Trusted Platform Module (TPM) Emulator for Linux
  * Copyright (C) 2004 Mario Strasser <mast@gmx.net>,
  *                    Swiss Federal Institute of Technology (ETH) Zurich
+ * Copyright (C) 2005 INTEL Corp
  *
  * This module is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published
@@ -45,14 +46,14 @@ void tpm_audit_request(TPM_COMMAND_CODE 
       tpmData.permanent.data.auditMonotonicCounter++;
     }
     /* update audit digest */
-    *((UINT16*)&buf[0])  = cpu_to_be16(TPM_TAG_AUDIT_EVENT_IN);
-    *((UINT32*)&buf[2]) = cpu_to_be32(ordinal);
+    *((UINT16*)&buf[0])  = CPU_TO_BE16(TPM_TAG_AUDIT_EVENT_IN);
+    *((UINT32*)&buf[2]) = CPU_TO_BE32(ordinal);
     sha1_init(&sha1_ctx);
     sha1_update(&sha1_ctx, req->param, req->paramSize);
     sha1_final(&sha1_ctx, &buf[6]);
-    *((UINT16*)&buf[26])  = cpu_to_be16(TPM_TAG_COUNTER_VALUE);
+    *((UINT16*)&buf[26])  = CPU_TO_BE16(TPM_TAG_COUNTER_VALUE);
     memset(&buf[30], 0, 4);
-    *((UINT32*)&buf[34]) = cpu_to_be32(tpmData.permanent.data.auditMonotonicCounter);
+    *((UINT32*)&buf[34]) = CPU_TO_BE32(tpmData.permanent.data.auditMonotonicCounter);
     sha1_init(&sha1_ctx);
     sha1_update(&sha1_ctx, tpmData.stany.data.auditDigest.digest, 
       sizeof(TPM_DIGEST));
@@ -70,15 +71,15 @@ void tpm_audit_response(TPM_COMMAND_CODE
       && (AUDIT_STATUS[ord / 8] & (1 << (ord & 0x07)))) {
     info("tpm_audit_response()");
     /* update audit digest */
-    *((UINT16*)&buf[0])  = cpu_to_be16(TPM_TAG_AUDIT_EVENT_OUT);
-    *((UINT32*)&buf[2]) = cpu_to_be32(ordinal);
+    *((UINT16*)&buf[0])  = CPU_TO_BE16(TPM_TAG_AUDIT_EVENT_OUT);
+    *((UINT32*)&buf[2]) = CPU_TO_BE32(ordinal);
     sha1_init(&sha1_ctx);
     sha1_update(&sha1_ctx, rsp->param, rsp->paramSize);
     sha1_final(&sha1_ctx, &buf[6]);
-    *((UINT16*)&buf[26])  = cpu_to_be16(TPM_TAG_COUNTER_VALUE);
+    *((UINT16*)&buf[26])  = CPU_TO_BE16(TPM_TAG_COUNTER_VALUE);
     memset(&buf[30], 0, 4);
-    *((UINT32*)&buf[34]) = cpu_to_be32(tpmData.permanent.data.auditMonotonicCounter);
-    *((UINT32*)&buf[34]) = cpu_to_be32(rsp->result);
+    *((UINT32*)&buf[34]) = CPU_TO_BE32(tpmData.permanent.data.auditMonotonicCounter);
+    *((UINT32*)&buf[34]) = CPU_TO_BE32(rsp->result);
     sha1_init(&sha1_ctx);
     sha1_update(&sha1_ctx, tpmData.stany.data.auditDigest.digest, 
       sizeof(TPM_DIGEST));
@@ -158,7 +159,7 @@ TPM_RESULT TPM_GetAuditDigestSigned(TPM_
   }
   memcpy(&buf[0], "\x05\x00ADIG", 6);
   memcpy(&buf[6], antiReplay->nonce, 20);
-  *(UINT32*)&buf[26] = cpu_to_be32(buf_size - 30);
+  *(UINT32*)&buf[26] = CPU_TO_BE32(buf_size - 30);
   memcpy(&buf[30], auditDigest->digest, 20);
   ptr = &buf[50];
   len = buf_size - 50;
@@ -198,4 +199,3 @@ TPM_RESULT TPM_SetOrdinalAuditStatus(TPM
   }
   return TPM_SUCCESS;
 }
-
diff -uprN tpm_emulator-0.3-x86_64/tpm/tpm_authorization.c tpm_emulator/tpm/tpm_authorization.c
--- tpm_emulator-0.3-x86_64/tpm/tpm_authorization.c	2006-08-29 15:07:21.620298760 -0700
+++ tpm_emulator/tpm/tpm_authorization.c	2006-08-29 15:26:17.108678288 -0700
@@ -1,6 +1,7 @@
 /* Software-Based Trusted Platform Module (TPM) Emulator for Linux
  * Copyright (C) 2004 Mario Strasser <mast@gmx.net>,
  *                    Swiss Federal Institute of Technology (ETH) Zurich
+ * Copyright (C) 2005 INTEL Corp
  *
  * This module is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published
@@ -279,7 +280,7 @@ TPM_RESULT tpm_verify_auth(TPM_AUTH *aut
 {
   hmac_ctx_t ctx;
   TPM_SESSION_DATA *session;
-  UINT32 auth_handle = cpu_to_be32(auth->authHandle);
+  UINT32 auth_handle = CPU_TO_BE32(auth->authHandle);
   
   info("tpm_verify_auth(%08x)", auth->authHandle);
   /* get dedicated authorization or transport session */
diff -uprN tpm_emulator-0.3-x86_64/tpm/tpm_capability.c tpm_emulator/tpm/tpm_capability.c
--- tpm_emulator-0.3-x86_64/tpm/tpm_capability.c	2006-08-29 15:07:21.620298760 -0700
+++ tpm_emulator/tpm/tpm_capability.c	2006-08-29 15:26:17.109678136 -0700
@@ -1,6 +1,7 @@
 /* Software-Based Trusted Platform Module (TPM) Emulator for Linux
  * Copyright (C) 2004 Mario Strasser <mast@gmx.net>,
  *                    Swiss Federal Institute of Technology (ETH) Zurich
+ * Copyright (C) 2005 INTEL Corp
  *
  * This module is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published
@@ -406,7 +407,7 @@ TPM_RESULT TPM_GetCapability(TPM_CAPABIL
 
     case TPM_CAP_KEY_HANDLE:
       debug("[TPM_CAP_KEY_HANDLE]");
-      subCapSize = cpu_to_be32(TPM_RT_KEY);
+      subCapSize = CPU_TO_BE32(TPM_RT_KEY);
       return cap_handle(4, (BYTE*)&subCapSize, respSize, resp);
 
     case TPM_CAP_CHECK_LOADED:
@@ -480,4 +481,3 @@ TPM_RESULT TPM_GetCapability(TPM_CAPABIL
       return TPM_BAD_MODE;
   }
 }
-
diff -uprN tpm_emulator-0.3-x86_64/tpm/tpm_cmd_handler.c tpm_emulator/tpm/tpm_cmd_handler.c
--- tpm_emulator-0.3-x86_64/tpm/tpm_cmd_handler.c	2006-08-29 15:07:21.621298608 -0700
+++ tpm_emulator/tpm/tpm_cmd_handler.c	2006-08-29 15:26:17.113677528 -0700
@@ -1,6 +1,7 @@
 /* Software-Based Trusted Platform Module (TPM) Emulator for Linux
  * Copyright (C) 2004 Mario Strasser <mast@gmx.net>,
  *                    Swiss Federal Institute of Technology (ETH) Zurich
+ * Copyright (C) 2005 INTEL Corp
  *
  * This module is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published
@@ -73,7 +74,7 @@ void tpm_compute_in_param_digest(TPM_REQ
 {
   sha1_ctx_t sha1;
   UINT32 offset = tpm_get_param_offset(req->ordinal);
-  UINT32 ord = cpu_to_be32(req->ordinal);
+  UINT32 ord = CPU_TO_BE32(req->ordinal);
 
   /* compute SHA1 hash */
   if (offset <= req->paramSize) {
@@ -89,8 +90,8 @@ void tpm_compute_in_param_digest(TPM_REQ
 void tpm_compute_out_param_digest(TPM_COMMAND_CODE ordinal, TPM_RESPONSE *rsp)
 {
   sha1_ctx_t sha1;
-  UINT32 res = cpu_to_be32(rsp->result);
-  UINT32 ord = cpu_to_be32(ordinal);
+  UINT32 res = CPU_TO_BE32(rsp->result);
+  UINT32 ord = CPU_TO_BE32(ordinal);
 
   /* compute SHA1 hash */
   sha1_init(&sha1);
@@ -3123,7 +3124,7 @@ static void tpm_setup_rsp_auth(TPM_COMMA
       hmac_update(&hmac, rsp->auth2->digest, sizeof(rsp->auth2->digest));
 #if 0
       if (tpm_get_auth(rsp->auth2->authHandle)->type == TPM_ST_OIAP) {
-        UINT32 handle = cpu_to_be32(rsp->auth2->authHandle);
+        UINT32 handle = CPU_TO_BE32(rsp->auth2->authHandle);
         hmac_update(&hmac, (BYTE*)&handle, 4);
       }
 #endif
@@ -3138,7 +3139,7 @@ static void tpm_setup_rsp_auth(TPM_COMMA
       hmac_update(&hmac, rsp->auth1->digest, sizeof(rsp->auth1->digest));
 #if 0
       if (tpm_get_auth(rsp->auth1->authHandle)->type == TPM_ST_OIAP) {
-        UINT32 handle = cpu_to_be32(rsp->auth1->authHandle);
+        UINT32 handle = CPU_TO_BE32(rsp->auth1->authHandle);
         hmac_update(&hmac, (BYTE*)&handle, 4);
       }
 #endif
@@ -3221,7 +3222,9 @@ extern const char *tpm_error_to_string(T
 void tpm_execute_command(TPM_REQUEST *req, TPM_RESPONSE *rsp)
 {
   TPM_RESULT res;
-  
+
+  req->tag = (BYTE) req->tag;  // FIXME: Why is this here
+
   /* setup authorisation as well as response tag and size */
   memset(rsp, 0, sizeof(*rsp));
   switch (req->tag) {
diff -uprN tpm_emulator-0.3-x86_64/tpm/tpm_crypto.c tpm_emulator/tpm/tpm_crypto.c
--- tpm_emulator-0.3-x86_64/tpm/tpm_crypto.c	2006-08-29 15:07:43.531967680 -0700
+++ tpm_emulator/tpm/tpm_crypto.c	2006-08-29 15:26:17.114677376 -0700
@@ -1,6 +1,7 @@
 /* Software-Based Trusted Platform Module (TPM) Emulator for Linux
  * Copyright (C) 2004 Mario Strasser <mast@gmx.net>,
  *                    Swiss Federal Institute of Technology (ETH) Zurich
+ * Copyright (C) 2005 INTEL Corp
  *
  * This module is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published
@@ -106,7 +107,7 @@ TPM_RESULT tpm_sign(TPM_KEY_DATA *key, T
     /* setup TPM_SIGN_INFO structure */
     memcpy(&buf[0], "\x05\x00SIGN", 6);
     memcpy(&buf[6], auth->nonceOdd.nonce, 20);
-    *(UINT32*)&buf[26] = cpu_to_be32(areaToSignSize);
+    *(UINT32*)&buf[26] = CPU_TO_BE32(areaToSignSize);
     memcpy(&buf[30], areaToSign, areaToSignSize);
     if (rsa_sign(&key->key, RSA_SSA_PKCS1_SHA1, 
         buf, areaToSignSize + 30, *sig)) {
@@ -383,4 +384,3 @@ TPM_RESULT TPM_CertifyKey2(TPM_KEY_HANDL
   }
   return TPM_SUCCESS;
 }
-
diff -uprN tpm_emulator-0.3-x86_64/tpm/tpm_daa.c tpm_emulator/tpm/tpm_daa.c
--- tpm_emulator-0.3-x86_64/tpm/tpm_daa.c	2006-08-29 15:07:21.622298456 -0700
+++ tpm_emulator/tpm/tpm_daa.c	2006-08-29 15:26:17.119676616 -0700
@@ -700,14 +700,14 @@ info("tested until here");
           sizeof(session->DAA_tpmSpecific.DAA_rekey));
       sha1_update(&sha1, (BYTE*) &session->DAA_tpmSpecific.DAA_count, 
           sizeof(session->DAA_tpmSpecific.DAA_count));
-      sha1_update(&sha1, "\x00", 1);
+      sha1_update(&sha1, (BYTE *) "\x00", 1);
       sha1_final(&sha1, scratch);
       sha1_init(&sha1);
       sha1_update(&sha1, (BYTE*) &session->DAA_tpmSpecific.DAA_rekey, 
           sizeof(session->DAA_tpmSpecific.DAA_rekey));
       sha1_update(&sha1, (BYTE*) &session->DAA_tpmSpecific.DAA_count, 
           sizeof(session->DAA_tpmSpecific.DAA_count));
-      sha1_update(&sha1, "\x01", 1);
+      sha1_update(&sha1, (BYTE *) "\x01", 1);
       sha1_final(&sha1, scratch + SHA1_DIGEST_LENGTH);
       mpz_init(f), mpz_init(q);
       mpz_import(f, 2 * SHA1_DIGEST_LENGTH, 1, 1, 0, 0, scratch);
@@ -787,14 +787,14 @@ info("tested until here");
           sizeof(session->DAA_tpmSpecific.DAA_rekey));
       sha1_update(&sha1, (BYTE*) &session->DAA_tpmSpecific.DAA_count, 
           sizeof(session->DAA_tpmSpecific.DAA_count));
-      sha1_update(&sha1, "\x00", 1);
+      sha1_update(&sha1, (BYTE *) "\x00", 1);
       sha1_final(&sha1, scratch);
       sha1_init(&sha1);
       sha1_update(&sha1, (BYTE*) &session->DAA_tpmSpecific.DAA_rekey, 
           sizeof(session->DAA_tpmSpecific.DAA_rekey));
       sha1_update(&sha1, (BYTE*) &session->DAA_tpmSpecific.DAA_count, 
           sizeof(session->DAA_tpmSpecific.DAA_count));
-      sha1_update(&sha1, "\x01", 1);
+      sha1_update(&sha1, (BYTE *) "\x01", 1);
       sha1_final(&sha1, scratch + SHA1_DIGEST_LENGTH);
       mpz_init(f), mpz_init(q);
       mpz_import(f, 2 * SHA1_DIGEST_LENGTH, 1, 1, 0, 0, scratch);
@@ -1440,14 +1440,14 @@ info("tested until here");
           sizeof(session->DAA_tpmSpecific.DAA_rekey));
       sha1_update(&sha1, (BYTE*) &session->DAA_tpmSpecific.DAA_count, 
           sizeof(session->DAA_tpmSpecific.DAA_count));
-      sha1_update(&sha1, "\x00", 1);
+      sha1_update(&sha1, (BYTE *) "\x00", 1);
       sha1_final(&sha1, scratch);
       sha1_init(&sha1);
       sha1_update(&sha1, (BYTE*) &session->DAA_tpmSpecific.DAA_rekey, 
           sizeof(session->DAA_tpmSpecific.DAA_rekey));
       sha1_update(&sha1, (BYTE*) &session->DAA_tpmSpecific.DAA_count, 
           sizeof(session->DAA_tpmSpecific.DAA_count));
-      sha1_update(&sha1, "\x01", 1);
+      sha1_update(&sha1, (BYTE *) "\x01", 1);
       sha1_final(&sha1, scratch + SHA1_DIGEST_LENGTH);
       mpz_init(f), mpz_init(q);
       mpz_import(f, 2 * SHA1_DIGEST_LENGTH, 1, 1, 0, 0, scratch);
@@ -1660,14 +1660,14 @@ info("tested until here");
           sizeof(session->DAA_tpmSpecific.DAA_rekey));
       sha1_update(&sha1, (BYTE*) &session->DAA_tpmSpecific.DAA_count, 
           sizeof(session->DAA_tpmSpecific.DAA_count));
-      sha1_update(&sha1, "\x00", 1);
+      sha1_update(&sha1, (BYTE *) "\x00", 1);
       sha1_final(&sha1, scratch);
       sha1_init(&sha1);
       sha1_update(&sha1, (BYTE*) &session->DAA_tpmSpecific.DAA_rekey, 
           sizeof(session->DAA_tpmSpecific.DAA_rekey));
       sha1_update(&sha1, (BYTE*) &session->DAA_tpmSpecific.DAA_count, 
           sizeof(session->DAA_tpmSpecific.DAA_count));
-      sha1_update(&sha1, "\x01", 1);
+      sha1_update(&sha1, (BYTE *) "\x01", 1);
       sha1_final(&sha1, scratch + SHA1_DIGEST_LENGTH);
       mpz_init(f), mpz_init(q);
       mpz_import(f, 2 * SHA1_DIGEST_LENGTH, 1, 1, 0, 0, scratch);
@@ -1740,14 +1740,14 @@ info("tested until here");
           sizeof(session->DAA_tpmSpecific.DAA_rekey));
       sha1_update(&sha1, (BYTE*) &session->DAA_tpmSpecific.DAA_count, 
           sizeof(session->DAA_tpmSpecific.DAA_count));
-      sha1_update(&sha1, "\x00", 1);
+      sha1_update(&sha1, (BYTE *) "\x00", 1);
       sha1_final(&sha1, scratch);
       sha1_init(&sha1);
       sha1_update(&sha1, (BYTE*) &session->DAA_tpmSpecific.DAA_rekey, 
           sizeof(session->DAA_tpmSpecific.DAA_rekey));
       sha1_update(&sha1, (BYTE*) &session->DAA_tpmSpecific.DAA_count, 
           sizeof(session->DAA_tpmSpecific.DAA_count));
-      sha1_update(&sha1, "\x01", 1);
+      sha1_update(&sha1, (BYTE *) "\x01", 1);
       sha1_final(&sha1, scratch + SHA1_DIGEST_LENGTH);
       mpz_init(f), mpz_init(q);
       mpz_import(f, 2 * SHA1_DIGEST_LENGTH, 1, 1, 0, 0, scratch);
@@ -2828,14 +2828,14 @@ TPM_RESULT TPM_DAA_Sign(TPM_HANDLE handl
           sizeof(session->DAA_tpmSpecific.DAA_rekey));
       sha1_update(&sha1, (BYTE*) &session->DAA_tpmSpecific.DAA_count, 
           sizeof(session->DAA_tpmSpecific.DAA_count));
-      sha1_update(&sha1, "\x00", 1);
+      sha1_update(&sha1, (BYTE *) "\x00", 1);
       sha1_final(&sha1, scratch);
       sha1_init(&sha1);
       sha1_update(&sha1, (BYTE*) &session->DAA_tpmSpecific.DAA_rekey, 
           sizeof(session->DAA_tpmSpecific.DAA_rekey));
       sha1_update(&sha1, (BYTE*) &session->DAA_tpmSpecific.DAA_count, 
           sizeof(session->DAA_tpmSpecific.DAA_count));
-      sha1_update(&sha1, "\x01", 1);
+      sha1_update(&sha1, (BYTE *) "\x01", 1);
       sha1_final(&sha1, scratch + SHA1_DIGEST_LENGTH);
       mpz_init(f), mpz_init(q);
       mpz_import(f, 2 * SHA1_DIGEST_LENGTH, 1, 1, 0, 0, scratch);
@@ -3050,7 +3050,7 @@ TPM_RESULT TPM_DAA_Sign(TPM_HANDLE handl
         sha1_init(&sha1);
         sha1_update(&sha1, (BYTE*) &session->DAA_session.DAA_digest, 
           sizeof(session->DAA_session.DAA_digest));
-        sha1_update(&sha1, "\x01", 1);
+        sha1_update(&sha1, (BYTE *) "\x01", 1);
         sha1_update(&sha1, inputData1, inputSize1);
         sha1_final(&sha1, (BYTE*) &session->DAA_session.DAA_digest);
       }
@@ -3078,7 +3078,7 @@ TPM_RESULT TPM_DAA_Sign(TPM_HANDLE handl
         sha1_init(&sha1);
         sha1_update(&sha1, (BYTE*) &session->DAA_session.DAA_digest, 
           sizeof(session->DAA_session.DAA_digest));
-        sha1_update(&sha1, "\x01", 1);
+        sha1_update(&sha1, (BYTE *) "\x01", 1);
         rsa_export_modulus(&aikData->key, scratch, &size);
         sha1_update(&sha1, scratch, size);
         sha1_final(&sha1, (BYTE*) &session->DAA_session.DAA_digest);
@@ -3134,14 +3134,14 @@ TPM_RESULT TPM_DAA_Sign(TPM_HANDLE handl
           sizeof(session->DAA_tpmSpecific.DAA_rekey));
       sha1_update(&sha1, (BYTE*) &session->DAA_tpmSpecific.DAA_count, 
           sizeof(session->DAA_tpmSpecific.DAA_count));
-      sha1_update(&sha1, "\x00", 1);
+      sha1_update(&sha1, (BYTE *) "\x00", 1);
       sha1_final(&sha1, scratch);
       sha1_init(&sha1);
       sha1_update(&sha1, (BYTE*) &session->DAA_tpmSpecific.DAA_rekey, 
           sizeof(session->DAA_tpmSpecific.DAA_rekey));
       sha1_update(&sha1, (BYTE*) &session->DAA_tpmSpecific.DAA_count, 
           sizeof(session->DAA_tpmSpecific.DAA_count));
-      sha1_update(&sha1, "\x01", 1);
+      sha1_update(&sha1, (BYTE *) "\x01", 1);
       sha1_final(&sha1, scratch + SHA1_DIGEST_LENGTH);
       mpz_init(f), mpz_init(q);
       mpz_import(f, 2 * SHA1_DIGEST_LENGTH, 1, 1, 0, 0, scratch);
@@ -3213,14 +3213,14 @@ TPM_RESULT TPM_DAA_Sign(TPM_HANDLE handl
           sizeof(session->DAA_tpmSpecific.DAA_rekey));
       sha1_update(&sha1, (BYTE*) &session->DAA_tpmSpecific.DAA_count, 
           sizeof(session->DAA_tpmSpecific.DAA_count));
-      sha1_update(&sha1, "\x00", 1);
+      sha1_update(&sha1, (BYTE *) "\x00", 1);
       sha1_final(&sha1, scratch);
       sha1_init(&sha1);
       sha1_update(&sha1, (BYTE*) &session->DAA_tpmSpecific.DAA_rekey, 
           sizeof(session->DAA_tpmSpecific.DAA_rekey));
       sha1_update(&sha1, (BYTE*) &session->DAA_tpmSpecific.DAA_count, 
           sizeof(session->DAA_tpmSpecific.DAA_count));
-      sha1_update(&sha1, "\x01", 1);
+      sha1_update(&sha1, (BYTE *) "\x01", 1);
       sha1_final(&sha1, scratch + SHA1_DIGEST_LENGTH);
       mpz_init(f), mpz_init(q);
       mpz_import(f, 2 * SHA1_DIGEST_LENGTH, 1, 1, 0, 0, scratch);
diff -uprN tpm_emulator-0.3-x86_64/tpm/tpm_data.c tpm_emulator/tpm/tpm_data.c
--- tpm_emulator-0.3-x86_64/tpm/tpm_data.c	2006-08-29 15:08:20.535342312 -0700
+++ tpm_emulator/tpm/tpm_data.c	2006-08-29 15:26:17.121676312 -0700
@@ -150,44 +150,43 @@ void tpm_release_data(void)
 
 #ifdef TPM_STORE_TO_FILE
 
-#include <linux/fs.h>
-#include <linux/unistd.h>
-#include <asm/uaccess.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <unistd.h>
 
 #define TPM_STORAGE_FILE "/var/tpm/tpm_emulator-1.2." STR(VERSION_MAJOR) "." STR(VERSION_MINOR) 
 
 static int write_to_file(uint8_t *data, size_t data_length)
 {
   int res;
-  struct file *fp;
-  mm_segment_t old_fs = get_fs();
-  fp = filp_open(TPM_STORAGE_FILE, O_WRONLY | O_TRUNC | O_CREAT, S_IRUSR | S_IWUSR);
-  if (IS_ERR(fp)) return -1;
-  set_fs(get_ds());
-  res = fp->f_op->write(fp, data, data_length, &fp->f_pos);
-  set_fs(old_fs);
-  filp_close(fp, NULL);
+  int fp;
+  fp = open(TPM_STORAGE_FILE, O_WRONLY | O_TRUNC | O_CREAT, S_IRUSR | S_IWUSR);
+  res = write(fp, data, data_length);
+  close(fp);
   return (res == data_length) ? 0 : -1;
 }
 
 static int read_from_file(uint8_t **data, size_t *data_length)
 {
   int res;
-  struct file *fp;
-  mm_segment_t old_fs = get_fs();
-  fp = filp_open(TPM_STORAGE_FILE, O_RDONLY, 0);
-  if (IS_ERR(fp)) return -1;
-  *data_length = (size_t)fp->f_dentry->d_inode->i_size;
-  /* *data_length = i_size_read(fp->f_dentry->d_inode); */
+  int fp, file_status;
+  struct stat file_info;
+  fp = open(TPM_STORAGE_FILE, O_RDONLY, 0);
+  file_status = fstat(fp, &file_info);
+  if (file_status < 0) {
+    close(fp);
+    return -1;
+  } 
+
+  *data_length = file_info.st_size; 
   *data = tpm_malloc(*data_length);
   if (*data == NULL) {
-    filp_close(fp, NULL);
+    close(fp);
     return -1;
   }
-  set_fs(get_ds());
-  res = fp->f_op->read(fp, *data, *data_length, &fp->f_pos);
-  set_fs(old_fs);
-  filp_close(fp, NULL);
+  res = read(fp, *data, *data_length);
+  close(fp);
   if (res != *data_length) {
     tpm_free(*data);
     return -1;
@@ -278,7 +277,7 @@ int tpm_restore_permanent_data(void)
 
 int tpm_erase_permanent_data(void)
 {
-  int res = write_to_file("", 0);
+  int res = write_to_file((uint8_t *) "", 0);
   return res;
 }
 
diff -uprN tpm_emulator-0.3-x86_64/tpm/tpm_data.c.orig tpm_emulator/tpm/tpm_data.c.orig
--- tpm_emulator-0.3-x86_64/tpm/tpm_data.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ tpm_emulator/tpm/tpm_data.c.orig	2006-08-29 15:26:08.469991568 -0700
@@ -0,0 +1,284 @@
+/* Software-Based Trusted Platform Module (TPM) Emulator for Linux
+ * Copyright (C) 2004 Mario Strasser <mast@gmx.net>,
+ *                    Swiss Federal Institute of Technology (ETH) Zurich
+ *
+ * This module is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ * This module is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * $Id: tpm_data.c 36 2005-10-26 20:31:19Z hstamer $
+ */
+
+#include "tpm_emulator.h"
+#include "tpm_structures.h"
+#include "tpm_marshalling.h"
+#include "linux_module.h"
+
+TPM_DATA tpmData;
+
+BOOL tpm_get_physical_presence(void)
+{
+  return (tpmData.stclear.flags.physicalPresence || TRUE);
+}
+
+static inline void init_pcr_attr(int pcr, BOOL reset, BYTE rl, BYTE el)
+{
+  int i;
+  tpmData.permanent.data.pcrAttrib[pcr].pcrReset = reset;
+  for (i = 0; i < TPM_NUM_LOCALITY; i++) {
+    tpmData.permanent.data.pcrAttrib[pcr].pcrResetLocal[i] = (rl & (1 << i));
+    tpmData.permanent.data.pcrAttrib[pcr].pcrExtendLocal[i] = (el & (1 << i));
+  }
+}
+
+void tpm_init_data(void)
+{
+  /* endorsement key */
+  uint8_t ek_n[] =  "\xa8\xdb\xa9\x42\xa8\xf3\xb8\x06\x85\x90\x76\x93\xad\xf7"
+    "\x74\xec\x3f\xd3\x3d\x9d\xe8\x2e\xff\x15\xed\x0e\xce\x5f\x93"
+    "\x92\xeb\xd1\x96\x2b\x72\x18\x81\x79\x12\x9d\x9c\x40\xd7\x1a"
+    "\x21\xda\x5f\x56\xe0\xc9\x48\x31\xdd\x96\xdc\xbb\x45\xc6\x8e"
+    "\xad\x58\x23\xcb\xbe\xbb\x13\x2d\x6b\x86\xc5\x57\xf5\xdd\x48"
+    "\xc1\x3d\xcd\x4d\xda\x81\xc4\x43\x17\xaa\x05\x40\x33\x62\x0a"
+    "\x59\xdb\x28\xcd\xb5\x08\x31\xbb\x06\xf5\xf7\x71\xae\x21\xa8"
+    "\xf2\x2f\x0e\x17\x80\x5d\x9c\xdf\xaa\xe9\x89\x09\x54\x65\x2b"
+    "\x46\xfb\x9d\xb2\x00\x70\x63\x0d\x9a\x6d\x3d\x5e\x11\x78\x65"
+    "\x90\xe6\x26\xee\x77\xbe\x08\xff\x07\x60\x5a\xcc\xf1\x0a\xbd"
+    "\x44\x92\x6b\xca\xb6\xce\x66\xf9\x93\x40\xae\xf3\x3e\x53\x02"
+    "\x3c\xa6\x81\xb3\xbe\xad\x6e\x6c\xa6\xf0\xeb\xdf\xe9\xa2\x83"
+    "\x36\x0e\x52\x0d\x64\x17\xd9\xff\xa1\x74\x7c\x2b\xbc\x6a\xcc"
+    "\xe5\x4e\xb4\x52\xd9\xec\x43\xbd\x26\x6a\x2b\x19\x19\x6e\x97"
+    "\xb8\x1d\x9f\x7b\xe7\x32\x2d\xdd\x7c\x51\xc8\xe4\xf3\x02\xd4"
+    "\x7c\x90\x44\xa0\x33\x72\x81\x75\xa9\x16\x27\x5c\x00\x1d\x07"
+    "\x81\xd4\xf7\xac\xcb\xfe\xd6\x60\x03\x6f\x7a\xcc\x00\xd1\xc4"
+    "\x85\x37";
+  uint8_t ek_e[] = "\x01\x00\x01";
+  uint8_t ek_p[] = "\xd7\xea\x61\x15\x8b\xa3\x71\xdf\xa8\x74\x77\xca\x88\x95"
+    "\xd0\x76\x17\x43\x2c\xf6\x23\x27\x44\xb9\x0e\x18\x35\x7e\xe4"
+    "\xc3\xcb\x13\x6e\xfc\x38\x02\x1e\x77\x26\x40\x9d\x17\xb2\x39"
+    "\x9c\x7f\x5f\x98\xe6\xf2\x55\x0c\x12\x05\x4c\xb3\x51\xae\x29"
+    "\xe7\xcd\xce\x41\x0b\x28\x4d\x97\x13\x4b\x60\xc8\xd8\x70\x81"
+    "\xf9\x1c\x12\x44\xdf\x53\x0a\x87\x9d\x33\x92\x4a\x34\x69\xf0"
+    "\x70\x5e\x1b\x5d\x65\xc7\x84\x90\xa2\x62\xdf\x83\x14\x10\x69"
+    "\xe2\xa7\x18\x43\xd7\x1f\x60\xc9\x03\x8f\xd6\xa4\xce\xb2\x9d"
+    "\x40\x37\x70\x17\x4c\xe3\x69\xd4\x59";
+  uint8_t ek_q[] = "\xc8\x34\xd2\xd0\x7c\xfa\xdc\x68\xe2\x72\xd7\x92\xe2\x50"
+    "\x93\xfc\xbb\x72\x55\x4d\x6b\x7a\x0c\x0b\xcf\x87\x66\x1f\x81"
+    "\x71\xf3\x50\xcb\xaa\xe6\x43\x7e\xbe\x11\xc4\xec\x00\x53\xf4"
+    "\x78\x13\x2b\x59\x26\x4a\x9f\x91\x61\x8f\xa7\x07\x64\x11\x5a"
+    "\xf4\xaf\x9c\x9b\x5a\x5d\x69\x20\x17\x55\x74\xba\xd8\xe4\x59"
+    "\x39\x1a\x0a\x7b\x4a\x30\xf0\xc8\x7f\xd9\xaf\x72\xc5\xb6\x71"
+    "\xd1\xc0\x8b\x5b\xa2\x2e\xa7\x15\xca\x50\x75\x10\x48\x9c\x2b"
+    "\x18\xb9\x67\x8f\x5d\x64\xc3\x28\x9f\x2f\x16\x2f\x08\xda\x47"
+    "\xec\x86\x43\x0c\x80\x99\x07\x34\x0f";
+  int i;
+  /* reset all data to NULL, FALSE or 0 */
+  memset(&tpmData, 0, sizeof(tpmData));
+  tpmData.permanent.data.tag = TPM_TAG_PERMANENT_DATA;
+  /* set permanent flags */
+  tpmData.permanent.flags.tag = TPM_TAG_PERMANENT_FLAGS;
+  tpmData.permanent.flags.disable = FALSE;
+  tpmData.permanent.flags.deactivated = FALSE;
+  tpmData.permanent.flags.ownership = TRUE;
+  tpmData.permanent.flags.readPubek = TRUE;
+  tpmData.permanent.flags.allowMaintenance = TRUE;
+  tpmData.permanent.flags.enableRevokeEK = TRUE;
+  /* set TPM vision */
+  tpmData.permanent.data.version.major = 1;
+  tpmData.permanent.data.version.minor = 2;
+  tpmData.permanent.data.version.revMajor = VERSION_MAJOR;
+  tpmData.permanent.data.version.revMinor = VERSION_MINOR;
+  /* setup PCR attributes */
+  for (i = 0; i < min(16, TPM_NUM_PCR); i++) {
+    init_pcr_attr(i, FALSE, 0x00, 0x1f);
+  }
+  if (TPM_NUM_PCR >= 24) {
+    init_pcr_attr(16, TRUE, 0x1f, 0x1f);
+    init_pcr_attr(17, TRUE, 0x10, 0x1c);
+    init_pcr_attr(18, TRUE, 0x10, 0x1c);
+    init_pcr_attr(19, TRUE, 0x10, 0x0c);
+    init_pcr_attr(20, TRUE, 0x14, 0x0e);
+    init_pcr_attr(21, TRUE, 0x04, 0x04);
+    init_pcr_attr(22, TRUE, 0x04, 0x04);
+    init_pcr_attr(23, TRUE, 0x1f, 0x1f);
+  }
+  for (i = 24; i < TPM_NUM_PCR; i++) {
+    init_pcr_attr(i, TRUE, 0x00, 0x00);
+  }
+  /* set tick type */
+  tpmData.permanent.data.tickType = TICK_INC;
+#ifdef TPM_GENERATE_EK
+  /* generate a new endorsement key */
+  rsa_generate_key(&tpmData.permanent.data.endorsementKey, 2048);
+#else
+  /* setup endorsement key */
+  rsa_import_key(&tpmData.permanent.data.endorsementKey, 
+    RSA_MSB_FIRST, ek_n, 256, ek_e, 3, ek_p, ek_q);
+#endif
+#ifdef TPM_GENERATE_SEED_DAA
+  /* generate the DAA seed (cf. [TPM_Part2], v1.2 rev 85, Section 7.4) */
+  tpm_get_random_bytes(tpmData.permanent.data.tpmDAASeed.digest, 
+    sizeof(tpmData.permanent.data.tpmDAASeed.digest));
+#else
+  /* FIXME: setup DAA seed */
+  memcpy(tpmData.permanent.data.tpmDAASeed.digest, 
+    "\x77\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
+    "\x00\x00\x00\x77", 20);
+#endif
+
+  memcpy(tpmData.permanent.data.ekReset.nonce, "\xde\xad\xbe\xef", 4);
+}
+
+void tpm_release_data(void)
+{
+  int i;
+  /* release the EK, SRK as well as all other rsa keys */
+  if (tpmData.permanent.data.endorsementKey.size > 0)
+    rsa_release_private_key(&tpmData.permanent.data.endorsementKey);
+  if (tpmData.permanent.data.srk.valid)
+    rsa_release_private_key(&tpmData.permanent.data.srk.key);
+  for (i = 0; i < TPM_MAX_KEYS; i++)
+    if (tpmData.permanent.data.keys[i].valid)
+      rsa_release_private_key(&tpmData.permanent.data.keys[i].key);
+}
+
+#ifdef TPM_STORE_TO_FILE
+
+#include <linux/fs.h>
+#include <linux/unistd.h>
+#include <asm/uaccess.h>
+
+#define TPM_STORAGE_FILE "/var/tpm/tpm_emulator-1.2." STR(VERSION_MAJOR) "." STR(VERSION_MINOR) 
+
+static int write_to_file(uint8_t *data, size_t data_length)
+{
+  int res;
+  struct file *fp;
+  mm_segment_t old_fs = get_fs();
+  fp = filp_open(TPM_STORAGE_FILE, O_WRONLY | O_TRUNC | O_CREAT, S_IRUSR | S_IWUSR);
+  if (IS_ERR(fp)) return -1;
+  set_fs(get_ds());
+  res = fp->f_op->write(fp, data, data_length, &fp->f_pos);
+  set_fs(old_fs);
+  filp_close(fp, NULL);
+  return (res == data_length) ? 0 : -1;
+}
+
+static int read_from_file(uint8_t **data, size_t *data_length)
+{
+  int res;
+  struct file *fp;
+  mm_segment_t old_fs = get_fs();
+  fp = filp_open(TPM_STORAGE_FILE, O_RDONLY, 0);
+  if (IS_ERR(fp)) return -1;
+  *data_length = (size_t)fp->f_dentry->d_inode->i_size;
+  /* *data_length = i_size_read(fp->f_dentry->d_inode); */
+  *data = tpm_malloc(*data_length);
+  if (*data == NULL) {
+    filp_close(fp, NULL);
+    return -1;
+  }
+  set_fs(get_ds());
+  res = fp->f_op->read(fp, *data, *data_length, &fp->f_pos);
+  set_fs(old_fs);
+  filp_close(fp, NULL);
+  if (res != *data_length) {
+    tpm_free(*data);
+    return -1;
+  }
+  return 0;
+}
+
+#else
+
+static int write_to_file(uint8_t *data, size_t data_length)
+{
+  info("TPM_STORE_TO_FILE disabled, no data written");
+  return 0;
+}
+
+static int read_from_file(uint8_t **data, size_t *data_length)
+{
+  info("TPM_STORE_TO_FILE disabled, no data read");
+  return 0;
+}
+
+#endif /* TPM_STORE_TO_FILE */
+
+int tpm_store_permanent_data(void)
+{
+  uint8_t *buf, *ptr;
+  UINT32 buf_length, len;
+
+  /* marshal data */
+  buf_length = len = 4 + sizeof_TPM_STCLEAR_FLAGS(tpmData.stclear.flags)
+    + sizeof_TPM_PERMANENT_FLAGS(tpmData.permanent.flags) 
+    + sizeof_TPM_STANY_FLAGS(tpmData.stany.flags) + 2
+    + sizeof_TPM_STCLEAR_DATA(tpmData.stclear.data) 
+    + sizeof_TPM_PERMANENT_DATA(tpmData.permanent.data)
+    + sizeof_TPM_STANY_DATA(tpmData.stany.data);
+  buf = ptr = tpm_malloc(buf_length);
+  if (buf == NULL
+      || tpm_marshal_TPM_VERSION(&ptr, &len, &tpmData.permanent.data.version)
+      || tpm_marshal_TPM_STCLEAR_FLAGS(&ptr, &len, &tpmData.stclear.flags)
+      || tpm_marshal_TPM_PERMANENT_FLAGS(&ptr, &len, &tpmData.permanent.flags)
+      || tpm_marshal_TPM_STANY_FLAGS(&ptr, &len, &tpmData.stany.flags)
+      || tpm_marshal_BOOL(&ptr, &len, tpmData.permanent.flags.selfTestSucceeded)
+      || tpm_marshal_BOOL(&ptr, &len, tpmData.permanent.flags.owned)
+      || tpm_marshal_TPM_STCLEAR_DATA(&ptr, &len, &tpmData.stclear.data)
+      || tpm_marshal_TPM_PERMANENT_DATA(&ptr, &len, &tpmData.permanent.data)
+      || tpm_marshal_TPM_STANY_DATA(&ptr, &len, &tpmData.stany.data)) {
+    tpm_free(buf);
+    return -1;
+  }
+
+  if (write_to_file(buf, buf_length - len)) {
+    tpm_free(buf);
+    return -1; 
+  }
+  tpm_free(buf);
+  return 0;
+}
+
+int tpm_restore_permanent_data(void)
+{
+  uint8_t *buf, *ptr;
+  size_t buf_length;
+  UINT32 len;
+  TPM_VERSION ver;
+
+  /* read data */
+  if (read_from_file(&buf, &buf_length)) return -1;
+  ptr = buf;
+  len = (uint32_t) buf_length;
+  /* unmarshal data */
+  if (tpm_unmarshal_TPM_VERSION(&ptr, &len, &ver)
+      || memcmp(&ver, &tpmData.permanent.data.version, sizeof(TPM_VERSION))
+      || tpm_unmarshal_TPM_STCLEAR_FLAGS(&ptr, &len, &tpmData.stclear.flags)
+      || tpm_unmarshal_TPM_PERMANENT_FLAGS(&ptr, &len, &tpmData.permanent.flags)
+      || tpm_unmarshal_TPM_STANY_FLAGS(&ptr, &len, &tpmData.stany.flags)
+      || tpm_unmarshal_BOOL(&ptr, &len, &tpmData.permanent.flags.selfTestSucceeded)
+      || tpm_unmarshal_BOOL(&ptr, &len, &tpmData.permanent.flags.owned)
+      || tpm_unmarshal_TPM_STCLEAR_DATA(&ptr, &len, &tpmData.stclear.data)
+      || tpm_unmarshal_TPM_PERMANENT_DATA(&ptr, &len, &tpmData.permanent.data)
+      || tpm_unmarshal_TPM_STANY_DATA(&ptr, &len, &tpmData.stany.data)) {
+    tpm_free(buf);
+    return -1;
+  }
+
+  tpm_free(buf);
+  return 0;
+}
+
+int tpm_erase_permanent_data(void)
+{
+  int res = write_to_file("", 0);
+  return res;
+}
+
diff -uprN tpm_emulator-0.3-x86_64/tpm/tpm_deprecated.c tpm_emulator/tpm/tpm_deprecated.c
--- tpm_emulator-0.3-x86_64/tpm/tpm_deprecated.c	2006-08-29 15:07:21.622298456 -0700
+++ tpm_emulator/tpm/tpm_deprecated.c	2006-08-29 15:26:17.122676160 -0700
@@ -1,6 +1,7 @@
 /* Software-Based Trusted Platform Module (TPM) Emulator for Linux
  * Copyright (C) 2004 Mario Strasser <mast@gmx.net>,
  *                    Swiss Federal Institute of Technology (ETH) Zurich
+ * Copyright (C) 2005 INTEL Corp
  *
  * This module is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published
@@ -50,7 +51,7 @@ TPM_RESULT TPM_SaveKeyContext(TPM_KEY_HA
   BYTE *ptr;
   UINT32 len;
   info("TPM_SaveKeyContext()");
-  res = TPM_SaveContext(keyHandle, TPM_RT_KEY, "SaveKeyContext..", 
+  res = TPM_SaveContext(keyHandle, TPM_RT_KEY, (BYTE*)"SaveKeyContext..", 
                         keyContextSize, &contextBlob);
   if (res != TPM_SUCCESS) return res;
   len = *keyContextSize;
@@ -82,7 +83,7 @@ TPM_RESULT TPM_SaveAuthContext(TPM_AUTHH
   BYTE *ptr;
   UINT32 len;
   info("TPM_SaveAuthContext()");
-  res = TPM_SaveContext(authHandle, TPM_RT_KEY, "SaveAuthContext.", 
+  res = TPM_SaveContext(authHandle, TPM_RT_KEY, (BYTE*)"SaveAuthContext.", 
                         authContextSize, &contextBlob);
   if (res != TPM_SUCCESS) return res;
   len = *authContextSize;
diff -uprN tpm_emulator-0.3-x86_64/tpm/tpm_emulator.h tpm_emulator/tpm/tpm_emulator.h
--- tpm_emulator-0.3-x86_64/tpm/tpm_emulator.h	2006-08-29 15:07:21.648294504 -0700
+++ tpm_emulator/tpm/tpm_emulator.h	2006-08-29 15:26:17.122676160 -0700
@@ -1,5 +1,6 @@
 /* Software-Based Trusted Platform Module (TPM) Emulator for Linux
  * Copyright (C) 2004 Mario Strasser <mast@gmx.net>,
+ * Copyright (C) 2005 INTEL Corp
  *
  * This module is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published
@@ -22,7 +23,8 @@
 /* TPM configuration */
 #define TPM_STORE_TO_FILE       1
 #undef  TPM_STRONG_PERSISTENCE
-#undef  TPM_GENERATE_EK
+//#undef  TPM_GENERATE_EK
+#define  TPM_GENERATE_EK
 #undef  TPM_GENERATE_SEED_DAA
 
 #define TPM_MANUFACTURER 0x4554485A /* 'ETHZ' */        
diff -uprN tpm_emulator-0.3-x86_64/tpm/tpm_integrity.c tpm_emulator/tpm/tpm_integrity.c
--- tpm_emulator-0.3-x86_64/tpm/tpm_integrity.c	2006-08-29 15:07:21.645294960 -0700
+++ tpm_emulator/tpm/tpm_integrity.c	2006-08-29 15:26:17.123676008 -0700
@@ -1,6 +1,7 @@
 /* Software-Based Trusted Platform Module (TPM) Emulator for Linux
  * Copyright (C) 2004 Mario Strasser <mast@gmx.net>,
  *                    Swiss Federal Institute of Technology (ETH) Zurich
+ * Copyright (C) 2005 INTEL Corp
  *
  * This module is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published
@@ -194,4 +195,3 @@ TPM_RESULT tpm_verify_pcr(TPM_KEY_DATA *
   }
   return TPM_SUCCESS;
 }
-
diff -uprN tpm_emulator-0.3-x86_64/tpm/tpm_structures.h tpm_emulator/tpm/tpm_structures.h
--- tpm_emulator-0.3-x86_64/tpm/tpm_structures.h	2006-08-29 15:08:20.545340792 -0700
+++ tpm_emulator/tpm/tpm_structures.h	2006-08-29 15:26:17.125675704 -0700
@@ -1,6 +1,7 @@
 /* Software-Based Trusted Platform Module (TPM) Emulator for Linux
  * Copyright (C) 2004 Mario Strasser <mast@gmx.net>,
  *                    Swiss Federal Institute of Technology (ETH) Zurich
+ * Copyright (C) 2005 INTEL Corp
  *
  * This module is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published
@@ -18,7 +19,7 @@
 #ifndef _TPM_STRUCTURES_H_
 #define _TPM_STRUCTURES_H_
 
-#include <linux/types.h>
+//#include <linux/types.h>
 #include "crypto/rsa.h"
 
 /*
diff -uprN tpm_emulator-0.3-x86_64/tpm/tpm_testing.c tpm_emulator/tpm/tpm_testing.c
--- tpm_emulator-0.3-x86_64/tpm/tpm_testing.c	2006-08-29 15:07:21.646294808 -0700
+++ tpm_emulator/tpm/tpm_testing.c	2006-08-29 15:26:17.127675400 -0700
@@ -1,6 +1,7 @@
 /* Software-Based Trusted Platform Module (TPM) Emulator for Linux
  * Copyright (C) 2004 Mario Strasser <mast@gmx.net>,
  *                    Swiss Federal Institute of Technology (ETH) Zurich
+ * Copyright (C) 2005 INTEL Corp
  *
  * This module is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published
@@ -95,24 +96,24 @@ static int tpm_test_sha1(void)
   struct {
     uint8_t *data; uint32_t repetitions; uint8_t *digest;
   } test_cases[] =  {{
-    "abc", 1,
-    "\xA9\x99\x3E\x36\x47\x06\x81\x6A\xBA\x3E\x25\x71\x78\x50\xC2\x6C\x9C\xD0\xD8\x9D"
+	(uint8_t*)"abc", 1,
+    (uint8_t*)"\xA9\x99\x3E\x36\x47\x06\x81\x6A\xBA\x3E\x25\x71\x78\x50\xC2\x6C\x9C\xD0\xD8\x9D"
   }, {
-    "abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq", 1,
-    "\x84\x98\x3E\x44\x1C\x3B\xD2\x6E\xBA\xAE\x4A\xA1\xF9\x51\x29\xE5\xE5\x46\x70\xF1"
+    (uint8_t*)"abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq", 1,
+    (uint8_t*)"\x84\x98\x3E\x44\x1C\x3B\xD2\x6E\xBA\xAE\x4A\xA1\xF9\x51\x29\xE5\xE5\x46\x70\xF1"
   }, {
-    "a", 1000000,
-    "\x34\xAA\x97\x3C\xD4\xC4\xDA\xA4\xF6\x1E\xEB\x2B\xDB\xAD\x27\x31\x65\x34\x01\x6F"
+    (uint8_t*)"a", 1000000,
+    (uint8_t*)"\x34\xAA\x97\x3C\xD4\xC4\xDA\xA4\xF6\x1E\xEB\x2B\xDB\xAD\x27\x31\x65\x34\x01\x6F"
   }, {
-    "0123456701234567012345670123456701234567012345670123456701234567", 10,
-    "\xDE\xA3\x56\xA2\xCD\xDD\x90\xC7\xA7\xEC\xED\xC5\xEB\xB5\x63\x93\x4F\x46\x04\x52"
+    (uint8_t*)"0123456701234567012345670123456701234567012345670123456701234567", 10,
+    (uint8_t*)"\xDE\xA3\x56\xA2\xCD\xDD\x90\xC7\xA7\xEC\xED\xC5\xEB\xB5\x63\x93\x4F\x46\x04\x52"
   }};
 
   debug("tpm_test_sha1()");
   for (i = 0; i < sizeof(test_cases) / sizeof(test_cases[0]); i++) {
     sha1_init(&ctx);
     for (j = 0; j < test_cases[i].repetitions; j++)
-      sha1_update(&ctx, test_cases[i].data, strlen(test_cases[i].data));
+      sha1_update(&ctx, test_cases[i].data, strlen((char*)test_cases[i].data));
     sha1_final(&ctx, digest);
     if (memcmp(digest, test_cases[i].digest, SHA1_DIGEST_LENGTH) != 0) return -1;
   }
@@ -128,41 +129,41 @@ static int tpm_test_hmac(void)
   struct {
     uint8_t *key, key_len, *data, data_len, *digest;
   } test_cases[] = {{
-    "\x0b", 20, "Hi There", 8,
-    "\xb6\x17\x31\x86\x55\x05\x72\x64\xe2\x8b\xc0\xb6\xfb\x37\x8c\x8e\xf1\x46\xbe\x00"
+    (uint8_t*)"\x0b", 20, (uint8_t*)"Hi There", 8,
+    (uint8_t*)"\xb6\x17\x31\x86\x55\x05\x72\x64\xe2\x8b\xc0\xb6\xfb\x37\x8c\x8e\xf1\x46\xbe\x00"
   }, {
-    "Jefe", 4, "what do ya want for nothing?", 28,
-    "\xef\xfc\xdf\x6a\xe5\xeb\x2f\xa2\xd2\x74\x16\xd5\xf1\x84\xdf\x9c\x25\x9a\x7c\x79"
+    (uint8_t*)"Jefe", 4, (uint8_t*)"what do ya want for nothing?", 28,
+    (uint8_t*)"\xef\xfc\xdf\x6a\xe5\xeb\x2f\xa2\xd2\x74\x16\xd5\xf1\x84\xdf\x9c\x25\x9a\x7c\x79"
   }, {
-    "\xaa", 20, "\xdd", 50,
-    "\x12\x5d\x73\x42\xb9\xac\x11\xcd\x91\xa3\x9a\xf4\x8a\xa1\x7b\x4f\x63\xf1\x75\xd3"
+    (uint8_t*)"\xaa", 20, (uint8_t*)"\xdd", 50,
+    (uint8_t*)"\x12\x5d\x73\x42\xb9\xac\x11\xcd\x91\xa3\x9a\xf4\x8a\xa1\x7b\x4f\x63\xf1\x75\xd3"
   }, {
-    "\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f\x10\x11\x12\x13\x14"
-    "\x15\x16\x17\x18\x19", 25, "\xcd", 50,
-    "\x4c\x90\x07\xf4\x02\x62\x50\xc6\xbc\x84\x14\xf9\xbf\x50\xc8\x6c\x2d\x72\x35\xda"
+    (uint8_t*)"\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f\x10\x11\x12\x13\x14"
+    "\x15\x16\x17\x18\x19", 25, (uint8_t*)"\xcd", 50,
+    (uint8_t*)"\x4c\x90\x07\xf4\x02\x62\x50\xc6\xbc\x84\x14\xf9\xbf\x50\xc8\x6c\x2d\x72\x35\xda"
   }, {
-    "\x0c", 20, "Test With Truncation", 20,
-    "\x4c\x1a\x03\x42\x4b\x55\xe0\x7f\xe7\xf2\x7b\xe1\xd5\x8b\xb9\x32\x4a\x9a\x5a\x04"
+    (uint8_t*)"\x0c", 20, (uint8_t*)"Test With Truncation", 20,
+    (uint8_t*)"\x4c\x1a\x03\x42\x4b\x55\xe0\x7f\xe7\xf2\x7b\xe1\xd5\x8b\xb9\x32\x4a\x9a\x5a\x04"
   }, {
-    "\xaa", 80, "Test Using Larger Than Block-Size Key - Hash Key First", 54,
-    "\xaa\x4a\xe5\xe1\x52\x72\xd0\x0e\x95\x70\x56\x37\xce\x8a\x3b\x55\xed\x40\x21\x12"
+    (uint8_t*)"\xaa", 80, (uint8_t*)"Test Using Larger Than Block-Size Key - Hash Key First", 54,
+    (uint8_t*)"\xaa\x4a\xe5\xe1\x52\x72\xd0\x0e\x95\x70\x56\x37\xce\x8a\x3b\x55\xed\x40\x21\x12"
   }, {
-    "\xaa", 80,
-    "Test Using Larger Than Block-Size Key and Larger Than One Block-Size Data", 73,
-    "\xe8\xe9\x9d\x0f\x45\x23\x7d\x78\x6d\x6b\xba\xa7\x96\x5c\x78\x08\xbb\xff\x1a\x91"
+    (uint8_t*)"\xaa", 80,
+    (uint8_t*)"Test Using Larger Than Block-Size Key and Larger Than One Block-Size Data", 73,
+    (uint8_t*)"\xe8\xe9\x9d\x0f\x45\x23\x7d\x78\x6d\x6b\xba\xa7\x96\x5c\x78\x08\xbb\xff\x1a\x91"
   }};
 
   debug("tpm_test_hmac()");
   for (i = 0; i < sizeof(test_cases) / sizeof(test_cases[0]); i++) {
-    if (strlen(test_cases[i].key) < test_cases[i].key_len) {
+    if (strlen((char*)test_cases[i].key) < test_cases[i].key_len) {
       uint8_t key[test_cases[i].key_len];
       memset(key, test_cases[i].key[0], test_cases[i].key_len);
       hmac_init(&ctx, key, test_cases[i].key_len);
     } else {
       hmac_init(&ctx, test_cases[i].key, test_cases[i].key_len);
     }
-    for (j = 0; j < test_cases[i].data_len; j += strlen(test_cases[i].data)) {
-      hmac_update(&ctx, test_cases[i].data, strlen(test_cases[i].data));
+    for (j = 0; j < test_cases[i].data_len; j += strlen((char*)test_cases[i].data)) {
+      hmac_update(&ctx, test_cases[i].data, strlen((char*)test_cases[i].data));
     }
     hmac_final(&ctx, digest);
     if (memcmp(digest, test_cases[i].digest, SHA1_DIGEST_LENGTH) != 0) return -1;
@@ -173,9 +174,9 @@ static int tpm_test_hmac(void)
 static int tpm_test_rsa_EK(void)
 {
   int res = 0;
-  char *data = "RSA PKCS #1 v1.5 Test-String";
+  uint8_t *data = (uint8_t*)"RSA PKCS #1 v1.5 Test-String";
   uint8_t buf[256];
-  size_t buf_len, data_len = strlen(data);
+  size_t buf_len, data_len = strlen((char*)data);
   rsa_private_key_t priv_key;
   rsa_public_key_t pub_key;
 
diff -uprN tpm_emulator-0.3-x86_64/tpm/tpm_ticks.c tpm_emulator/tpm/tpm_ticks.c
--- tpm_emulator-0.3-x86_64/tpm/tpm_ticks.c	2006-08-29 15:07:21.646294808 -0700
+++ tpm_emulator/tpm/tpm_ticks.c	2006-08-29 15:26:17.128675248 -0700
@@ -1,6 +1,7 @@
 /* Software-Based Trusted Platform Module (TPM) Emulator for Linux
  * Copyright (C) 2004 Mario Strasser <mast@gmx.net>,
  *                    Swiss Federal Institute of Technology (ETH) Zurich
+ * Copyright (C) 2005 INTEL Corp
  *
  * This module is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published
@@ -37,9 +38,7 @@ TPM_RESULT TPM_SetTickType(TPM_TICKTYPE 
 TPM_RESULT TPM_GetTicks(TPM_CURRENT_TICKS *currentTime)
 {
   info("TPM_GetTicks()");
-  memcpy(currentTime, &tpmData.stany.data.currentTicks, 
-    sizeof(TPM_CURRENT_TICKS));
-  return TPM_SUCCESS;
+  return TPM_DISABLED_CMD;
 }
 
 TPM_RESULT TPM_TickStampBlob(TPM_KEY_HANDLE keyHandle, TPM_NONCE *antiReplay,
@@ -47,61 +46,12 @@ TPM_RESULT TPM_TickStampBlob(TPM_KEY_HAN
                              TPM_CURRENT_TICKS *currentTicks, 
                              UINT32 *sigSize, BYTE **sig)
 {
-  TPM_RESULT res;
-  TPM_KEY_DATA *key;
-  BYTE *info, *p;
-  UINT32 info_length, length;
   info("TPM_TickStampBlob()");
-  /* get key */
-  key = tpm_get_key(keyHandle);
-  if (key == NULL) return TPM_INVALID_KEYHANDLE;
-  /* verify authorization */ 
-  res = tpm_verify_auth(auth1, key->usageAuth, keyHandle);
-  if (res != TPM_SUCCESS) return res;
-  if (key->keyUsage != TPM_KEY_SIGNING && key->keyUsage != TPM_KEY_LEGACY
-      && key->keyUsage != TPM_KEY_IDENTITY) return TPM_INVALID_KEYUSAGE;
-  /* get current ticks */
-  TPM_GetTicks(currentTicks);
-  /* sign data using signature scheme PKCS1_SHA1 and TPM_SIGN_INFO container */
-  *sigSize = key->key.size >> 3;
-  *sig = tpm_malloc(*sigSize);
-  if (*sig == NULL) return TPM_FAIL; 
-  /* setup TPM_SIGN_INFO structure */
-  info_length = 30 + sizeof(TPM_DIGEST) + sizeof_TPM_CURRENT_TICKS(currentTicks);
-  info = tpm_malloc(info_length);
-  if (info == NULL) {
-    tpm_free(*sig);
-    return TPM_FAIL;
-  }
-  memcpy(&info[0], "\x05\x00TSTP", 6);
-  memcpy(&info[6], antiReplay->nonce, 20);
-  *(UINT32*)&info[26] = cpu_to_be32(20
-                        + sizeof_TPM_CURRENT_TICKS(currentTicks));
-  memcpy(&info[30], digestToStamp->digest, sizeof(TPM_DIGEST));
-  p = &info[30 + sizeof(TPM_DIGEST)]; 
-  length = sizeof_TPM_CURRENT_TICKS(currentTicks);
-  if (tpm_marshal_TPM_CURRENT_TICKS(&p, &length, currentTicks)
-      || rsa_sign(&key->key, RSA_SSA_PKCS1_SHA1, info, info_length, *sig)) {   
-    tpm_free(*sig);
-    tpm_free(info);
-    return TPM_FAIL;
-  } 
-  return TPM_SUCCESS;
+  return TPM_DISABLED_CMD;
 }
 
 void tpm_update_ticks(void)
 {
-  if (tpmData.stany.data.currentTicks.tag == 0) {
-    tpmData.stany.data.currentTicks.tag = TPM_TAG_CURRENT_TICKS;
-    tpmData.stany.data.currentTicks.currentTicks += tpm_get_ticks();
-    tpmData.stany.data.currentTicks.tickType = tpmData.permanent.data.tickType;
-    tpm_get_random_bytes(tpmData.stany.data.currentTicks.tickNonce.nonce, 
-      sizeof(TPM_NONCE));
-    tpmData.stany.data.currentTicks.tickRate = 1;
-    tpmData.stany.data.currentTicks.tickSecurity = TICK_SEC_NO_CHECK;
-  } else {
-    tpmData.stany.data.currentTicks.currentTicks += tpm_get_ticks();   
-  }
 }
   
 
diff -uprN tpm_emulator-0.3-x86_64/tpm/tpm_transport.c tpm_emulator/tpm/tpm_transport.c
--- tpm_emulator-0.3-x86_64/tpm/tpm_transport.c	2006-08-29 15:07:21.647294656 -0700
+++ tpm_emulator/tpm/tpm_transport.c	2006-08-29 15:26:17.129675096 -0700
@@ -59,7 +59,7 @@ static int decrypt_transport_auth(TPM_KE
 static void transport_log_in(TPM_COMMAND_CODE ordinal, BYTE parameters[20],
                              BYTE pubKeyHash[20], TPM_DIGEST *transDigest)
 {
-  UINT32 tag = cpu_to_be32(TPM_TAG_TRANSPORT_LOG_IN);
+  UINT32 tag = CPU_TO_BE32(TPM_TAG_TRANSPORT_LOG_IN);
   BYTE *ptr, buf[sizeof_TPM_TRANSPORT_LOG_IN(x)];
   UINT32 len = sizeof(buf);
   sha1_ctx_t sha1;
@@ -76,7 +76,7 @@ static void transport_log_in(TPM_COMMAND
 static void transport_log_out(TPM_CURRENT_TICKS *currentTicks, BYTE parameters[20],
                               TPM_MODIFIER_INDICATOR locality, TPM_DIGEST *transDigest)
 {
-  UINT32 tag = cpu_to_be32(TPM_TAG_TRANSPORT_LOG_OUT);
+  UINT32 tag = CPU_TO_BE32(TPM_TAG_TRANSPORT_LOG_OUT);
   BYTE *ptr, buf[sizeof_TPM_TRANSPORT_LOG_OUT(x)];
   UINT32 len = sizeof(buf);
   sha1_ctx_t sha1;
@@ -191,7 +191,7 @@ static void decrypt_wrapped_command(BYTE
     sha1_update(&sha1, auth->nonceOdd.nonce, sizeof(auth->nonceOdd.nonce));
     sha1_update(&sha1, "in", 2);
     sha1_update(&sha1, secret, sizeof(TPM_SECRET));
-    j = cpu_to_be32(i);
+    j = CPU_TO_BE32(i);
     sha1_update(&sha1, (BYTE*)&j, 4);
     sha1_final(&sha1, mask);
     for (j = 0; j < sizeof(mask) && buf_len > 0; j++) { 
@@ -213,7 +213,7 @@ static void encrypt_wrapped_command(BYTE
     sha1_update(&sha1, auth->nonceOdd.nonce, sizeof(auth->nonceOdd.nonce));
     sha1_update(&sha1, "out", 3);
     sha1_update(&sha1, secret, sizeof(TPM_SECRET));
-    j = cpu_to_be32(i);
+    j = CPU_TO_BE32(i);
     sha1_update(&sha1, (BYTE*)&j, 4);
     sha1_final(&sha1, mask);
     for (j = 0; j < sizeof(mask) && buf_len > 0; j++) { 
@@ -253,9 +253,9 @@ TPM_RESULT TPM_ExecuteTransport(UINT32 i
   /* verify authorization */
   tpm_compute_in_param_digest(&req);
   sha1_init(&sha1);
-  res = cpu_to_be32(TPM_ORD_ExecuteTransport);
+  res = CPU_TO_BE32(TPM_ORD_ExecuteTransport);
   sha1_update(&sha1, (BYTE*)&res, 4);
-  res = cpu_to_be32(inWrappedCmdSize);
+  res = CPU_TO_BE32(inWrappedCmdSize);
   sha1_update(&sha1, (BYTE*)&res, 4);
   sha1_update(&sha1, req.auth1.digest, sizeof(req.auth1.digest));
   sha1_final(&sha1, auth1->digest);
@@ -357,7 +357,7 @@ TPM_RESULT TPM_ReleaseTransportSigned(TP
   /* setup a TPM_SIGN_INFO structure */
   memcpy(&buf[0], "\x05\x00TRAN", 6);
   memcpy(&buf[6], antiReplay->nonce, 20);
-  *(UINT32*)&buf[26] = cpu_to_be32(20);
+  *(UINT32*)&buf[26] = CPU_TO_BE32(20);
   memcpy(&buf[30], session->transInternal.transDigest.digest, 20);
   /* sign info structure */ 
   res = tpm_sign(key, auth1, TRUE, buf, sizeof(buf), signature, signSize);
diff -uprN tpm_emulator-0.3-x86_64/tpm_version.h tpm_emulator/tpm_version.h
--- tpm_emulator-0.3-x86_64/tpm_version.h	2006-08-29 15:07:21.649294352 -0700
+++ tpm_emulator/tpm_version.h	1969-12-31 16:00:00.000000000 -0800
@@ -1,6 +0,0 @@
-#ifndef _TPM_VERSION_H_
-#define _TPM_VERSION_H_
-#define VERSION_MAJOR 0
-#define VERSION_MINOR 3
-#define VERSION_BUILD 1136893683
-#endif /* _TPM_VERSION_H_ */
diff -uprN tpm_emulator-0.3-x86_64/tpmd.c tpm_emulator/tpmd.c
--- tpm_emulator-0.3-x86_64/tpmd.c	1969-12-31 16:00:00.000000000 -0800
+++ tpm_emulator/tpmd.c	2006-08-29 15:26:17.130674944 -0700
@@ -0,0 +1,141 @@
+/* Software-Based Trusted Platform Module (TPM) Emulator for Linux
+ * Copyright (C) 2005 INTEL Corp
+ *
+ * This module is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ * This module is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <string.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <sys/time.h>
+
+#include "tpm_emulator.h"
+
+#define TPM_RX_FNAME "/tmp/tpm_in.fifo"
+#define TPM_TX_FNAME "/tmp/tpm_out.fifo"
+
+#define BUFFER_SIZE 2048
+
+static int devurandom=0;
+	  
+void get_random_bytes(void *buf, int nbytes) {
+  
+  if (devurandom == 0) {
+    devurandom = open("/dev/urandom", O_RDONLY);
+  }
+
+  if (read(devurandom, buf, nbytes) != nbytes) {
+      printf("Can't get random number.\n");
+      exit(-1);
+  }
+}
+
+uint64_t tpm_get_ticks(void)
+{
+  //struct timeval tv;
+  //int gettimeofday(&tv, struct timezone *tz);
+  return 0;
+}
+
+int main(int argc, char **argv)
+{
+  uint8_t in[BUFFER_SIZE], *out;
+  uint32_t out_size;
+  int in_size, written;
+  int i;
+ 
+  int tpm_tx_fh=-1, tpm_rx_fh=-1;
+  if (argc < 2) {
+    printf("Usage: tpmd clear|save|deactivated\n" );
+	  return -1;
+  }
+
+  /* initialize TPM emulator */
+  if (!strcmp(argv[1], "clear")) {
+    printf("Initializing tpm: %s\n", argv[1]);
+    tpm_emulator_init(1);
+  } else if (!strcmp(argv[1], "save")) { 
+    printf("Initializing tpm: %s\n", argv[1]);
+    tpm_emulator_init(2);
+  } else if (!strcmp(argv[1], "deactivated")) {
+    printf("Initializing tpm: %s\n", argv[1]);
+    tpm_emulator_init(3);
+  } else {
+    printf("invalid startup mode '%s'; must be 'clear', "
+      "'save' (default) or 'deactivated", argv[1]);
+    return -1;
+  }
+
+  while (1) {
+abort_command:
+    if (tpm_rx_fh < 0) {
+      tpm_rx_fh = open(TPM_RX_FNAME, O_RDONLY);
+    }
+    
+    if (tpm_rx_fh < 0) {
+      printf("ERROR: failed to open devices to listen to guest.\n");
+      return -1;
+    }
+    
+    if (tpm_tx_fh < 0) {
+      tpm_tx_fh = open(TPM_TX_FNAME, O_WRONLY);
+    }
+
+    if (tpm_tx_fh < 0) {
+      printf("ERROR: failed to open devices to respond to guest.\n");
+      return -1;
+    }
+
+    in_size = read(tpm_rx_fh, in, BUFFER_SIZE);
+    if (in_size < 6) { // Magic size of minium TPM command
+      printf("Recv[%d] to small: 0x", in_size);
+      if (in_size <= 0) {
+          close(tpm_rx_fh);
+          tpm_rx_fh = -1;
+          goto abort_command;
+      }
+    } else { 
+      printf("Recv[%d]: 0x", in_size);
+      for (i=0; i< in_size; i++) 
+        printf("%x ", in[i]);
+      printf("\n");
+    }
+
+    
+    if (tpm_handle_command(in, in_size, &out, &out_size) != 0) { 
+        printf("ERROR: Handler Failed.\n");
+    }
+
+    written = write(tpm_tx_fh, out, out_size);
+
+    if (written != out_size ) {
+      printf("ERROR: Part of response not written %d/%d.\nAttempt: ", written, out_size);
+    } else {
+      printf("Sent[%Zu]: ", out_size);
+    }
+    for (i=0; i< out_size; i++)
+      printf("%x ", out[i]);
+    printf("\n");
+    tpm_free(out);
+
+  } // loop
+
+  tpm_emulator_shutdown();
+
+  close(tpm_tx_fh);
+  close(tpm_rx_fh);
+
+}
