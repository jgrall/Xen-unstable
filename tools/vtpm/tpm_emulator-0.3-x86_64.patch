diff -uprN orig/tpm_emulator-0.3/Makefile tpm_emulator-0.3-x86_64/Makefile
--- orig/tpm_emulator-0.3/Makefile	2006-01-10 04:21:45.000000000 -0800
+++ tpm_emulator-0.3-x86_64/Makefile	2006-08-29 15:08:20.532342768 -0700
@@ -7,6 +7,7 @@
 KERNEL_RELEASE := $(shell uname -r)
 KERNEL_BUILD   := /lib/modules/$(KERNEL_RELEASE)/build
 MOD_SUBDIR     := misc
+COMPILE_ARCH    ?= $(shell uname -m | sed -e s/i.86/x86_32/)
 
 # module settings
 MODULE_NAME    := tpm_emulator
@@ -17,8 +18,14 @@ VERSION_BUILD  := $(shell date +"%s")
 # enable/disable DEBUG messages
 EXTRA_CFLAGS   += -Wall -DDEBUG -g  
 
+ifeq ($(COMPILE_ARCH),x86_64)
+LIBDIR = lib64
+else
+LIBDIR = lib
+endif
+
 # GNU MP configuration
-GMP_LIB        := /usr/lib/libgmp.a
+GMP_LIB        := /usr/$(LIBDIR)/libgmp.a
 GMP_HEADER     := /usr/include/gmp.h
 
 # sources and objects
diff -uprN orig/tpm_emulator-0.3/README tpm_emulator-0.3-x86_64/README
--- orig/tpm_emulator-0.3/README	2006-01-10 04:21:45.000000000 -0800
+++ tpm_emulator-0.3-x86_64/README	2006-08-29 15:07:43.530967832 -0700
@@ -43,6 +43,12 @@ Example:
 GMP_LIB        := /usr/lib/libgmp.a
 GMP_HEADER     := /usr/include/gmp.h
 
+GNU MP Library on 64 bit Systems
+--------------------------------------------------------------------------
+Some 64-bit kernels have problems with importing the user-space gmp 
+library (/usr/lib*/libgmp.a) into kernel space.  These kernels will require
+that the gmp library be recompiled for kernel space with -mcmodel=kernel.
+
 Installation
 --------------------------------------------------------------------------
 The compilation and installation process uses the build environment for 
diff -uprN orig/tpm_emulator-0.3/crypto/gmp_kernel_wrapper.c tpm_emulator-0.3-x86_64/crypto/gmp_kernel_wrapper.c
--- orig/tpm_emulator-0.3/crypto/gmp_kernel_wrapper.c	2006-01-10 04:21:45.000000000 -0800
+++ tpm_emulator-0.3-x86_64/crypto/gmp_kernel_wrapper.c	2006-08-29 15:07:43.525968592 -0700
@@ -79,7 +79,7 @@ void __attribute__ ((regparm(0))) *kerne
 {
   void *ret  = (void*)kmalloc(size, GFP_KERNEL);
   if (!ret) panic(KERN_CRIT TPM_MODULE_NAME 
-    "GMP: cannot allocate memory (size=%u)\n", size);
+    "GMP: cannot allocate memory (size=%Zu)\n", size);
   return ret;
 }
 
@@ -88,7 +88,7 @@ void __attribute__ ((regparm(0))) *kerne
 {
   void *ret = (void*)kmalloc(new_size, GFP_KERNEL);
   if (!ret) panic(KERN_CRIT TPM_MODULE_NAME "GMP: Cannot reallocate memory "
-    "(old_size=%u new_size=%u)\n", old_size, new_size);
+    "(old_size=%Zu new_size=%Zu)\n", old_size, new_size);
   memcpy(ret, oldptr, old_size);
   kfree(oldptr);
   return ret;
diff -uprN orig/tpm_emulator-0.3/linux_module.c tpm_emulator-0.3-x86_64/linux_module.c
--- orig/tpm_emulator-0.3/linux_module.c	2006-01-10 04:21:45.000000000 -0800
+++ tpm_emulator-0.3-x86_64/linux_module.c	2006-08-29 15:07:43.526968440 -0700
@@ -72,7 +72,7 @@ static int tpm_release(struct inode *ino
 
 static ssize_t tpm_read(struct file *file, char *buf, size_t count, loff_t *ppos)
 {
-  debug("%s(%d)", __FUNCTION__, count);
+  debug("%s(%Zu)", __FUNCTION__, count);
   down(&tpm_mutex);
   if (tpm_response.data != NULL) {
     count = min(count, (size_t)tpm_response.size - (size_t)*ppos);
@@ -91,7 +91,7 @@ static ssize_t tpm_read(struct file *fil
 
 static ssize_t tpm_write(struct file *file, const char *buf, size_t count, loff_t *ppos)
 {
-  debug("%s(%d)", __FUNCTION__, count);
+  debug("%s(%Zu)", __FUNCTION__, count);
   down(&tpm_mutex);
   *ppos = 0;
   if (tpm_response.data != NULL) kfree(tpm_response.data);
diff -uprN orig/tpm_emulator-0.3/linux_module.h tpm_emulator-0.3-x86_64/linux_module.h
--- orig/tpm_emulator-0.3/linux_module.h	2006-01-10 04:21:45.000000000 -0800
+++ tpm_emulator-0.3-x86_64/linux_module.h	2006-08-29 15:07:43.527968288 -0700
@@ -28,8 +28,10 @@
 
 /* module settings */
 
+#ifndef STR
 #define STR(s) __STR__(s)
 #define __STR__(s) #s
+#endif
 #include "tpm_version.h"
 
 #define TPM_DEVICE_MINOR	224
diff -uprN orig/tpm_emulator-0.3/tpm/tpm_credentials.c tpm_emulator-0.3-x86_64/tpm/tpm_credentials.c
--- orig/tpm_emulator-0.3/tpm/tpm_credentials.c	2006-01-10 04:21:45.000000000 -0800
+++ tpm_emulator-0.3-x86_64/tpm/tpm_credentials.c	2006-08-29 15:07:43.530967832 -0700
@@ -47,16 +47,16 @@ int tpm_compute_pubkey_checksum(TPM_NONC
 
 TPM_RESULT tpm_get_pubek(TPM_PUBKEY *pubEndorsementKey)
 {
-  UINT32 key_length;
+  size_t key_length;
   if (!tpmData.permanent.data.endorsementKey.size) return TPM_NO_ENDORSEMENT;
   /* setup TPM_PUBKEY structure */
-  key_length = tpmData.permanent.data.endorsementKey.size;
-  pubEndorsementKey->pubKey.keyLength = key_length >> 3;
+  pubEndorsementKey->pubKey.keyLength = tpmData.permanent.data.endorsementKey.size >> 3;
   pubEndorsementKey->pubKey.key = tpm_malloc(pubEndorsementKey->pubKey.keyLength);
   if (pubEndorsementKey->pubKey.key == NULL) return TPM_FAIL;
   rsa_export_modulus(&tpmData.permanent.data.endorsementKey,
-    pubEndorsementKey->pubKey.key,
-    &pubEndorsementKey->pubKey.keyLength);
+		     pubEndorsementKey->pubKey.key,
+		     &key_length);
+  pubEndorsementKey->pubKey.keyLength = key_length;
   pubEndorsementKey->algorithmParms.algorithmID = TPM_ALG_RSA;
   pubEndorsementKey->algorithmParms.encScheme = TPM_ES_RSAESOAEP_SHA1_MGF1;
   pubEndorsementKey->algorithmParms.sigScheme = TPM_SS_NONE;
@@ -175,6 +175,7 @@ TPM_RESULT TPM_OwnerReadInternalPub(TPM_
 {
   TPM_RESULT res;
   TPM_KEY_DATA *srk = &tpmData.permanent.data.srk;
+  size_t key_length;
   info("TPM_OwnerReadInternalPub()");
   /* verify authorization */
   res = tpm_verify_auth(auth1, tpmData.permanent.data.ownerAuth, TPM_KH_OWNER);
@@ -186,7 +187,8 @@ TPM_RESULT TPM_OwnerReadInternalPub(TPM_
     publicPortion->pubKey.key = tpm_malloc(publicPortion->pubKey.keyLength);
     if (publicPortion->pubKey.key == NULL) return TPM_FAIL;
     rsa_export_modulus(&srk->key, publicPortion->pubKey.key, 
-      &publicPortion->pubKey.keyLength);
+      &key_length);
+    publicPortion->pubKey.keyLength = key_length;
     publicPortion->algorithmParms.algorithmID = TPM_ALG_RSA;
     publicPortion->algorithmParms.encScheme = srk->encScheme;
     publicPortion->algorithmParms.sigScheme = srk->sigScheme;
diff -uprN orig/tpm_emulator-0.3/tpm/tpm_crypto.c tpm_emulator-0.3-x86_64/tpm/tpm_crypto.c
--- orig/tpm_emulator-0.3/tpm/tpm_crypto.c	2006-01-10 04:21:45.000000000 -0800
+++ tpm_emulator-0.3-x86_64/tpm/tpm_crypto.c	2006-08-29 15:07:43.531967680 -0700
@@ -182,7 +182,8 @@ TPM_RESULT TPM_CertifyKey(TPM_KEY_HANDLE
   TPM_KEY_DATA *cert, *key;
   sha1_ctx_t sha1_ctx;
   BYTE *buf, *p;
-  UINT32 length;
+  UINT32 length32;
+  size_t length;
   info("TPM_CertifyKey()");
   /* get keys */
   cert = tpm_get_key(certHandle);
@@ -264,14 +265,15 @@ TPM_RESULT TPM_CertifyKey(TPM_KEY_HANDLE
   /* compute the digest of the CERTIFY_INFO[2] structure and sign it */
   length = sizeof_TPM_CERTIFY_INFO((*certifyInfo));
   p = buf = tpm_malloc(length);
+  length32=(UINT32) length;
   if (buf == NULL
-      || tpm_marshal_TPM_CERTIFY_INFO(&p, &length, certifyInfo)) {
+      || tpm_marshal_TPM_CERTIFY_INFO(&p, &length32, certifyInfo)) {
     free_TPM_KEY_PARMS(certifyInfo->algorithmParms);
     return TPM_FAIL;
   }
   length = sizeof_TPM_CERTIFY_INFO((*certifyInfo));
   sha1_init(&sha1_ctx);
-  sha1_update(&sha1_ctx, buf, length);
+  sha1_update(&sha1_ctx, buf, (size_t) length);
   sha1_final(&sha1_ctx, buf);
   res = tpm_sign(cert, auth1, FALSE, buf, SHA1_DIGEST_LENGTH, outData, outDataSize);
   tpm_free(buf);
@@ -292,7 +294,8 @@ TPM_RESULT TPM_CertifyKey2(TPM_KEY_HANDL
   TPM_KEY_DATA *cert, *key;
   sha1_ctx_t sha1_ctx;
   BYTE *buf, *p;
-  UINT32 length;
+  size_t length;
+  UINT32 length32;
   info("TPM_CertifyKey2()");
   /* get keys */
   cert = tpm_get_key(certHandle);
@@ -362,8 +365,9 @@ TPM_RESULT TPM_CertifyKey2(TPM_KEY_HANDL
   /* compute the digest of the CERTIFY_INFO[2] structure and sign it */
   length = sizeof_TPM_CERTIFY_INFO((*certifyInfo));
   p = buf = tpm_malloc(length);
+  length32 = (UINT32) length;
   if (buf == NULL
-      || tpm_marshal_TPM_CERTIFY_INFO(&p, &length, certifyInfo)) {
+      || tpm_marshal_TPM_CERTIFY_INFO(&p, &length32, certifyInfo)) {
     free_TPM_KEY_PARMS(certifyInfo->algorithmParms);
     return TPM_FAIL;
   }
diff -uprN orig/tpm_emulator-0.3/tpm/tpm_data.c tpm_emulator-0.3-x86_64/tpm/tpm_data.c
--- orig/tpm_emulator-0.3/tpm/tpm_data.c	2006-01-10 04:21:45.000000000 -0800
+++ tpm_emulator-0.3-x86_64/tpm/tpm_data.c	2006-08-29 15:08:20.535342312 -0700
@@ -214,23 +214,30 @@ static int read_from_file(uint8_t **data
 int tpm_store_permanent_data(void)
 {
   uint8_t *buf, *ptr;
-  size_t buf_length, len;
+  UINT32 buf_length, len;
 
   /* marshal data */
-  buf_length = len = sizeof_TPM_STCLEAR_FLAGS(tpmData.stclear.flags)
-    + sizeof_TPM_PERMANENT_FLAGS(tpmData.permanent.flags) + 2
-    + sizeof_TPM_PERMANENT_DATA(tpmData.permanent.data);
+  buf_length = len = 4 + sizeof_TPM_STCLEAR_FLAGS(tpmData.stclear.flags)
+    + sizeof_TPM_PERMANENT_FLAGS(tpmData.permanent.flags) 
+    + sizeof_TPM_STANY_FLAGS(tpmData.stany.flags) + 2
+    + sizeof_TPM_STCLEAR_DATA(tpmData.stclear.data) 
+    + sizeof_TPM_PERMANENT_DATA(tpmData.permanent.data)
+    + sizeof_TPM_STANY_DATA(tpmData.stany.data);
   buf = ptr = tpm_malloc(buf_length);
   if (buf == NULL
       || tpm_marshal_TPM_VERSION(&ptr, &len, &tpmData.permanent.data.version)
       || tpm_marshal_TPM_STCLEAR_FLAGS(&ptr, &len, &tpmData.stclear.flags)
       || tpm_marshal_TPM_PERMANENT_FLAGS(&ptr, &len, &tpmData.permanent.flags)
+      || tpm_marshal_TPM_STANY_FLAGS(&ptr, &len, &tpmData.stany.flags)
       || tpm_marshal_BOOL(&ptr, &len, tpmData.permanent.flags.selfTestSucceeded)
       || tpm_marshal_BOOL(&ptr, &len, tpmData.permanent.flags.owned)
-      || tpm_marshal_TPM_PERMANENT_DATA(&ptr, &len, &tpmData.permanent.data)) {
+      || tpm_marshal_TPM_STCLEAR_DATA(&ptr, &len, &tpmData.stclear.data)
+      || tpm_marshal_TPM_PERMANENT_DATA(&ptr, &len, &tpmData.permanent.data)
+      || tpm_marshal_TPM_STANY_DATA(&ptr, &len, &tpmData.stany.data)) {
     tpm_free(buf);
     return -1;
   }
+
   if (write_to_file(buf, buf_length - len)) {
     tpm_free(buf);
     return -1; 
@@ -242,24 +249,29 @@ int tpm_store_permanent_data(void)
 int tpm_restore_permanent_data(void)
 {
   uint8_t *buf, *ptr;
-  size_t buf_length, len;
+  size_t buf_length;
+  UINT32 len;
   TPM_VERSION ver;
 
   /* read data */
   if (read_from_file(&buf, &buf_length)) return -1;
   ptr = buf;
-  len = buf_length;
+  len = (uint32_t) buf_length;
   /* unmarshal data */
   if (tpm_unmarshal_TPM_VERSION(&ptr, &len, &ver)
       || memcmp(&ver, &tpmData.permanent.data.version, sizeof(TPM_VERSION))
       || tpm_unmarshal_TPM_STCLEAR_FLAGS(&ptr, &len, &tpmData.stclear.flags)
       || tpm_unmarshal_TPM_PERMANENT_FLAGS(&ptr, &len, &tpmData.permanent.flags)
+      || tpm_unmarshal_TPM_STANY_FLAGS(&ptr, &len, &tpmData.stany.flags)
       || tpm_unmarshal_BOOL(&ptr, &len, &tpmData.permanent.flags.selfTestSucceeded)
       || tpm_unmarshal_BOOL(&ptr, &len, &tpmData.permanent.flags.owned)
-      || tpm_unmarshal_TPM_PERMANENT_DATA(&ptr, &len, &tpmData.permanent.data)) {
+      || tpm_unmarshal_TPM_STCLEAR_DATA(&ptr, &len, &tpmData.stclear.data)
+      || tpm_unmarshal_TPM_PERMANENT_DATA(&ptr, &len, &tpmData.permanent.data)
+      || tpm_unmarshal_TPM_STANY_DATA(&ptr, &len, &tpmData.stany.data)) {
     tpm_free(buf);
     return -1;
   }
+
   tpm_free(buf);
   return 0;
 }
diff -uprN orig/tpm_emulator-0.3/tpm/tpm_marshalling.c tpm_emulator-0.3-x86_64/tpm/tpm_marshalling.c
--- orig/tpm_emulator-0.3/tpm/tpm_marshalling.c	2006-01-10 04:21:45.000000000 -0800
+++ tpm_emulator-0.3-x86_64/tpm/tpm_marshalling.c	2006-08-29 15:08:20.537342008 -0700
@@ -1212,7 +1212,7 @@ int tpm_unmarshal_TPM_STANY_FLAGS(BYTE *
 
 int tpm_marshal_RSA(BYTE **ptr, UINT32 *length, rsa_private_key_t *v)
 {
-  UINT32 m_len, e_len, q_len;
+  size_t m_len, e_len, q_len;
   if (*length < sizeof_RSA((*v))) return -1;
   if (v->size > 0) {
     rsa_export_modulus(v, &(*ptr)[6], &m_len);
@@ -1356,6 +1356,66 @@ int tpm_unmarshal_TPM_PERMANENT_DATA(BYT
   return 0;
 }
 
+int tpm_marshal_TPM_STCLEAR_DATA(BYTE **ptr, UINT32 *length, TPM_STCLEAR_DATA *v)
+{
+  if (tpm_marshal_TPM_STRUCTURE_TAG(ptr, length, v->tag)
+    || tpm_marshal_TPM_NONCE(ptr, length, &v->contextNonceKey)
+    || tpm_marshal_TPM_COUNT_ID(ptr, length, v->countID) ) return -1;
+
+  return 0;
+}
+
+int tpm_unmarshal_TPM_STCLEAR_DATA(BYTE **ptr, UINT32 *length, TPM_STCLEAR_DATA *v)
+{
+  if (tpm_unmarshal_TPM_STRUCTURE_TAG(ptr, length, &v->tag)
+    || tpm_unmarshal_TPM_NONCE(ptr, length, &v->contextNonceKey)
+    || tpm_unmarshal_TPM_COUNT_ID(ptr, length, &v->countID) ) return -1;
+
+  return 0;
+}
+
+int tpm_marshal_TPM_STANY_DATA(BYTE **ptr, UINT32 *length, TPM_STANY_DATA *v)
+{
+  UINT32 i;
+  if (tpm_marshal_TPM_STRUCTURE_TAG(ptr, length, v->tag)
+    || tpm_marshal_TPM_NONCE(ptr, length, &v->contextNonceSession)
+    || tpm_marshal_TPM_DIGEST(ptr, length, &v->auditDigest)
+    || tpm_marshal_BOOL(ptr, length, v->auditSession)
+    || tpm_marshal_TPM_CURRENT_TICKS(ptr, length, &v->currentTicks)
+    || tpm_marshal_UINT32(ptr, length, v->contextCount)
+    || tpm_marshal_UINT32_ARRAY(ptr, length, v->contextList, TPM_MAX_SESSION_LIST)) return -1;
+  for (i = 0; i < TPM_MAX_SESSIONS; i++) {
+    if (tpm_marshal_TPM_SESSION_DATA(ptr, length, &v->sessions[i])) return -1;
+  }
+  for (i = 0; i < TPM_MAX_SESSIONS_DAA; i++) {
+    if (tpm_marshal_TPM_DAA_SESSION_DATA(ptr, length, &v->sessionsDAA[i])) return -1;
+  }
+  if (tpm_marshal_TPM_TRANSHANDLE(ptr, length, v->transExclusive)) return -1;
+
+  return 0;
+}
+
+int tpm_unmarshal_TPM_STANY_DATA(BYTE **ptr, UINT32 *length, TPM_STANY_DATA *v)
+{
+  UINT32 i;
+  if (tpm_unmarshal_TPM_STRUCTURE_TAG(ptr, length, &v->tag)
+    || tpm_unmarshal_TPM_NONCE(ptr, length, &v->contextNonceSession)
+    || tpm_unmarshal_TPM_DIGEST(ptr, length, &v->auditDigest)
+    || tpm_unmarshal_BOOL(ptr, length, &v->auditSession)
+    || tpm_unmarshal_TPM_CURRENT_TICKS(ptr, length, &v->currentTicks)
+    || tpm_unmarshal_UINT32(ptr, length, &v->contextCount)
+    || tpm_unmarshal_UINT32_ARRAY(ptr, length, v->contextList, TPM_MAX_SESSION_LIST)) return -1;
+  for (i = 0; i < TPM_MAX_SESSIONS; i++) {
+    if (tpm_unmarshal_TPM_SESSION_DATA(ptr, length, &v->sessions[i])) return -1;
+  }
+  for (i = 0; i < TPM_MAX_SESSIONS_DAA; i++) {
+    if (tpm_unmarshal_TPM_DAA_SESSION_DATA(ptr, length, &v->sessionsDAA[i])) return -1;
+  }
+  if (tpm_unmarshal_TPM_TRANSHANDLE(ptr, length, &v->transExclusive)) return -1;
+
+  return 0;
+}
+
 int tpm_marshal_TPM_SESSION_DATA(BYTE **ptr, UINT32 *length, TPM_SESSION_DATA *v)
 {
   if (tpm_marshal_BYTE(ptr, length, v->type)
diff -uprN orig/tpm_emulator-0.3/tpm/tpm_marshalling.h tpm_emulator-0.3-x86_64/tpm/tpm_marshalling.h
--- orig/tpm_emulator-0.3/tpm/tpm_marshalling.h	2006-01-10 04:21:45.000000000 -0800
+++ tpm_emulator-0.3-x86_64/tpm/tpm_marshalling.h	2006-08-29 15:08:20.538341856 -0700
@@ -420,6 +420,12 @@ int tpm_unmarshal_TPM_KEY_DATA(BYTE **pt
 int tpm_marshal_TPM_PERMANENT_DATA(BYTE **ptr, UINT32 *length, TPM_PERMANENT_DATA *);
 int tpm_unmarshal_TPM_PERMANENT_DATA(BYTE **ptr, UINT32 *length, TPM_PERMANENT_DATA *);
 
+int tpm_marshal_TPM_STCLEAR_DATA(BYTE **ptr, UINT32 *length, TPM_STCLEAR_DATA *v);
+int tpm_unmarshal_TPM_STCLEAR_DATA(BYTE **ptr, UINT32 *length, TPM_STCLEAR_DATA *v);
+
+int tpm_marshal_TPM_STANY_DATA(BYTE **ptr, UINT32 *length, TPM_STANY_DATA *v);
+int tpm_unmarshal_TPM_STANY_DATA(BYTE **ptr, UINT32 *length, TPM_STANY_DATA *v);
+
 int tpm_marshal_TPM_SESSION_DATA(BYTE **ptr, UINT32 *length, TPM_SESSION_DATA *v);
 int tpm_unmarshal_TPM_SESSION_DATA(BYTE **ptr, UINT32 *length, TPM_SESSION_DATA *v);
 
diff -uprN orig/tpm_emulator-0.3/tpm/tpm_owner.c tpm_emulator-0.3-x86_64/tpm/tpm_owner.c
--- orig/tpm_emulator-0.3/tpm/tpm_owner.c	2006-01-10 04:21:45.000000000 -0800
+++ tpm_emulator-0.3-x86_64/tpm/tpm_owner.c	2006-08-29 15:07:43.535967072 -0700
@@ -108,7 +108,7 @@ TPM_RESULT TPM_TakeOwnership(TPM_PROTOCO
   TPM_RESULT res;
   rsa_private_key_t *ek = &tpmData.permanent.data.endorsementKey;
   TPM_KEY_DATA *srk = &tpmData.permanent.data.srk;
-  UINT32 buf_size = ek->size >> 3;
+  size_t buf_size = ek->size >> 3, key_length; 
   BYTE buf[buf_size];
 
   info("TPM_TakeOwnership()");
@@ -172,7 +172,8 @@ TPM_RESULT TPM_TakeOwnership(TPM_PROTOCO
     return TPM_FAIL;
   }
   rsa_export_modulus(&srk->key, srkPub->pubKey.key,
-    &srkPub->pubKey.keyLength);
+		     &key_length);
+  srkPub->pubKey.keyLength = (UINT32) key_length;
   /* setup tpmProof and set state to owned */
   tpm_get_random_bytes(tpmData.permanent.data.tpmProof.nonce, 
     sizeof(tpmData.permanent.data.tpmProof.nonce));
diff -uprN orig/tpm_emulator-0.3/tpm/tpm_startup.c tpm_emulator-0.3-x86_64/tpm/tpm_startup.c
--- orig/tpm_emulator-0.3/tpm/tpm_startup.c	2006-01-10 04:21:45.000000000 -0800
+++ tpm_emulator-0.3-x86_64/tpm/tpm_startup.c	2006-08-29 15:08:20.538341856 -0700
@@ -41,24 +41,29 @@ void TPM_Init(TPM_STARTUP_TYPE startupTy
 TPM_RESULT TPM_Startup(TPM_STARTUP_TYPE startupType)
 {
   int i;
+  int restore_fail;
   info("TPM_Startup(%d)", startupType);
   if (tpmData.stany.flags.postInitialise == FALSE) return TPM_INVALID_POSTINIT;
-  /* reset STANY_FLAGS */
-  SET_TO_ZERO(&tpmData.stany.flags);
-  tpmData.stany.flags.tag = TPM_TAG_STANY_FLAGS;
-  /* reset STANY_DATA (invalidates ALL sessions) */
-  SET_TO_ZERO(&tpmData.stany.data);
-  tpmData.stany.data.tag = TPM_TAG_STANY_DATA;
-  /* init session-context nonce */
-  SET_TO_RAND(&tpmData.stany.data.contextNonceSession);
+
+  /* try and restore state to get EK, SRK, etc */
+  restore_fail = tpm_restore_permanent_data();
+
   /* set data and flags according to the given startup type */
   if (startupType == TPM_ST_CLEAR) {
+    /* reset STANY_FLAGS */
+    SET_TO_ZERO(&tpmData.stany.flags);
+    tpmData.stany.flags.tag = TPM_TAG_STANY_FLAGS;
+    /* reset STANY_DATA (invalidates ALL sessions) */
+    SET_TO_ZERO(&tpmData.stany.data);
+    tpmData.stany.data.tag = TPM_TAG_STANY_DATA;
+    /* init session-context nonce */
+    SET_TO_RAND(&tpmData.stany.data.contextNonceSession);
     /* reset PCR values */
     for (i = 0; i < TPM_NUM_PCR; i++) {
-      if (tpmData.permanent.data.pcrAttrib[i].pcrReset)
-        SET_TO_ZERO(tpmData.permanent.data.pcrValue[i].digest);
+      if (!tpmData.permanent.data.pcrAttrib[i].pcrReset)
+        SET_TO_ZERO(&tpmData.permanent.data.pcrValue[i].digest);
       else
-        SET_TO_0xFF(tpmData.permanent.data.pcrValue[i].digest);
+        SET_TO_0xFF(&tpmData.permanent.data.pcrValue[i].digest);
     }
     /* reset STCLEAR_FLAGS */
     SET_TO_ZERO(&tpmData.stclear.flags);
@@ -77,7 +82,8 @@ TPM_RESULT TPM_Startup(TPM_STARTUP_TYPE 
     /* init key-context nonce */
     SET_TO_RAND(&tpmData.stclear.data.contextNonceKey);
   } else if (startupType == TPM_ST_STATE) {
-    if (tpm_restore_permanent_data()) {
+    /* restore must have been successful for TPM_ST_STATE */
+    if (restore_fail) {
       error("restoring permanent data failed");
       tpmData.permanent.data.testResult = "tpm_restore_permanent_data() failed";
       tpmData.permanent.flags.selfTestSucceeded = FALSE;
diff -uprN orig/tpm_emulator-0.3/tpm/tpm_storage.c tpm_emulator-0.3-x86_64/tpm/tpm_storage.c
--- orig/tpm_emulator-0.3/tpm/tpm_storage.c	2006-01-10 04:21:45.000000000 -0800
+++ tpm_emulator-0.3-x86_64/tpm/tpm_storage.c	2006-08-29 15:07:43.537966768 -0700
@@ -58,6 +58,7 @@ int encrypt_sealed_data(TPM_KEY_DATA *ke
                         BYTE *enc, UINT32 *enc_size)
 {
   UINT32 len;
+  size_t enc_size32 = *enc_size;
   BYTE *buf, *ptr;
   rsa_public_key_t pub_key;
   int scheme;
@@ -72,7 +73,7 @@ int encrypt_sealed_data(TPM_KEY_DATA *ke
   if (buf == NULL
       || tpm_marshal_TPM_SEALED_DATA(&ptr, &len, seal)
       || rsa_encrypt(&pub_key, scheme, buf, sizeof_TPM_SEALED_DATA((*seal)),
-                     enc, enc_size)) {
+                     enc, &enc_size32)) {
     tpm_free(buf);
     rsa_release_public_key(&pub_key);
     return -1;
@@ -85,7 +86,8 @@ int encrypt_sealed_data(TPM_KEY_DATA *ke
 int decrypt_sealed_data(TPM_KEY_DATA *key, BYTE *enc, UINT32 enc_size,
                         TPM_SEALED_DATA *seal, BYTE **buf) 
 {
-  UINT32 len;
+  size_t len;
+  UINT32 len32;
   BYTE *ptr;
   int scheme;
   switch (key->encScheme) {
@@ -96,8 +98,12 @@ int decrypt_sealed_data(TPM_KEY_DATA *ke
   len = enc_size;
   *buf = ptr = tpm_malloc(len);
   if (*buf == NULL
-      || rsa_decrypt(&key->key, scheme, enc, enc_size, *buf, &len)
-      || tpm_unmarshal_TPM_SEALED_DATA(&ptr, &len, seal)) {
+      || rsa_decrypt(&key->key, scheme, enc, enc_size, *buf, &len) ){
+    tpm_free(*buf);
+    return -1;
+  }
+  len32 = len;
+  if (tpm_unmarshal_TPM_SEALED_DATA(&ptr, &len32, seal)) {
     tpm_free(*buf);
     return -1;
   }
@@ -237,11 +243,12 @@ TPM_RESULT TPM_Unseal(TPM_KEY_HANDLE par
 
 TPM_RESULT TPM_UnBind(TPM_KEY_HANDLE keyHandle, UINT32 inDataSize,
                       BYTE *inData, TPM_AUTH *auth1, 
-                      UINT32 *outDataSize, BYTE **outData)
+                      UINT32 *outDataSize32, BYTE **outData)
 {
   TPM_RESULT res;
   TPM_KEY_DATA *key;
   int scheme;
+  size_t outDataSize;
   info("TPM_UnBind()");
   /* get key */
   key = tpm_get_key(keyHandle);
@@ -258,8 +265,8 @@ TPM_RESULT TPM_UnBind(TPM_KEY_HANDLE key
   /* the size of the input data muss be greater than zero */
   if (inDataSize == 0) return TPM_BAD_PARAMETER;
   /* decrypt data */
-  *outDataSize = inDataSize;
-  *outData = tpm_malloc(*outDataSize);
+  outDataSize = inDataSize;
+  *outData = tpm_malloc(outDataSize);
   if (*outData == NULL) return TPM_FAIL;
   switch (key->encScheme) {
     case TPM_ES_RSAESOAEP_SHA1_MGF1: scheme = RSA_ES_OAEP_SHA1; break;
@@ -267,20 +274,21 @@ TPM_RESULT TPM_UnBind(TPM_KEY_HANDLE key
     default: tpm_free(*outData); return TPM_DECRYPT_ERROR;
   }
   if (rsa_decrypt(&key->key, scheme, inData, inDataSize, 
-      *outData, outDataSize)) {
+      *outData, &outDataSize)) {
     tpm_free(*outData);
     return TPM_DECRYPT_ERROR;
   }
   /* verify data if it is of type TPM_BOUND_DATA */
   if (key->encScheme == TPM_ES_RSAESOAEP_SHA1_MGF1 
       || key->keyUsage != TPM_KEY_LEGACY) {
-    if (*outDataSize < 5 || memcmp(*outData, "\x01\x01\00\x00\x02", 5) != 0) {
+    if (outDataSize < 5 || memcmp(*outData, "\x01\x01\00\x00\x02", 5) != 0) {
       tpm_free(*outData);
       return TPM_DECRYPT_ERROR;
     }
-    *outDataSize -= 5;
-    memmove(*outData, &(*outData)[5], *outDataSize);
+    outDataSize -= 5;
+    memmove(*outData, &(*outData)[5], outDataSize);
   }
+  *outDataSize32 = (UINT32) outDataSize;
   return TPM_SUCCESS;
 }
 
@@ -311,12 +319,13 @@ static int verify_key_digest(TPM_KEY *ke
 }
 
 int encrypt_private_key(TPM_KEY_DATA *key, TPM_STORE_ASYMKEY *store,
-                        BYTE *enc, UINT32 *enc_size)
+                        BYTE *enc, UINT32 *enc_size32)
 {
   UINT32 len;
   BYTE *buf, *ptr;
   rsa_public_key_t pub_key;
   int scheme;
+  size_t enc_size;
   switch (key->encScheme) {
     case TPM_ES_RSAESOAEP_SHA1_MGF1: scheme = RSA_ES_OAEP_SHA1; break;
     case TPM_ES_RSAESPKCSv15: scheme = RSA_ES_PKCSV15; break;
@@ -328,11 +337,12 @@ int encrypt_private_key(TPM_KEY_DATA *ke
   if (buf == NULL
       || tpm_marshal_TPM_STORE_ASYMKEY(&ptr, &len, store)
       || rsa_encrypt(&pub_key, scheme, buf, sizeof_TPM_STORE_ASYMKEY((*store)),
-                     enc, enc_size)) {
+                     enc, &enc_size)) {
     tpm_free(buf);
     rsa_release_public_key(&pub_key);
     return -1;
   }
+  *enc_size32 = (UINT32) enc_size;
   tpm_free(buf);
   rsa_release_public_key(&pub_key);
   return 0;
@@ -341,7 +351,8 @@ int encrypt_private_key(TPM_KEY_DATA *ke
 int decrypt_private_key(TPM_KEY_DATA *key, BYTE *enc, UINT32 enc_size, 
                         TPM_STORE_ASYMKEY *store, BYTE **buf) 
 {
-  UINT32 len;
+  UINT32 len32;
+  size_t len;
   BYTE *ptr;
   int scheme;
   switch (key->encScheme) {
@@ -352,8 +363,12 @@ int decrypt_private_key(TPM_KEY_DATA *ke
   len = enc_size;
   *buf = ptr = tpm_malloc(len);
   if (*buf == NULL
-      || rsa_decrypt(&key->key, scheme, enc, enc_size, *buf, &len)
-      || tpm_unmarshal_TPM_STORE_ASYMKEY(&ptr, &len, store)) {
+      || rsa_decrypt(&key->key, scheme, enc, enc_size, *buf, &len) ) {
+    tpm_free(*buf);
+    return -1;
+  }
+  len32 = (UINT32) len;
+  if (tpm_unmarshal_TPM_STORE_ASYMKEY(&ptr, &len32, store)) {  
     tpm_free(*buf);
     return -1;
   }
@@ -371,7 +386,7 @@ TPM_RESULT TPM_CreateWrapKey(TPM_KEY_HAN
   TPM_SESSION_DATA *session;
   TPM_STORE_ASYMKEY store;
   rsa_private_key_t rsa;
-  UINT32 key_length;
+  size_t key_length;
 
   info("TPM_CreateWrapKey()");
   /* get parent key */
@@ -428,11 +443,11 @@ TPM_RESULT TPM_CreateWrapKey(TPM_KEY_HAN
   }
   if (compute_key_digest(wrappedKey, &store.pubDataDigest)) return TPM_FAIL;
   /* generate key and store it */
-  key_length = keyInfo->algorithmParms.parms.rsa.keyLength;
-  if (rsa_generate_key(&rsa, key_length)) return TPM_FAIL;
-  wrappedKey->pubKey.keyLength = key_length >> 3;
+  if (rsa_generate_key(&rsa, keyInfo->algorithmParms.parms.rsa.keyLength)) 
+    return TPM_FAIL;
+  wrappedKey->pubKey.keyLength = keyInfo->algorithmParms.parms.rsa.keyLength >> 3;
   wrappedKey->pubKey.key = tpm_malloc(wrappedKey->pubKey.keyLength);
-  store.privKey.keyLength = key_length >> 4;
+  store.privKey.keyLength = keyInfo->algorithmParms.parms.rsa.keyLength >> 4;
   store.privKey.key = tpm_malloc(store.privKey.keyLength);
   wrappedKey->encDataSize = parent->key.size >> 3;
   wrappedKey->encData = tpm_malloc(wrappedKey->encDataSize);
@@ -444,9 +459,11 @@ TPM_RESULT TPM_CreateWrapKey(TPM_KEY_HAN
     tpm_free(wrappedKey->encData);
     return TPM_FAIL;
   }
-  rsa_export_modulus(&rsa, wrappedKey->pubKey.key, 
-    &wrappedKey->pubKey.keyLength);
-  rsa_export_prime1(&rsa, store.privKey.key, &store.privKey.keyLength);
+  rsa_export_modulus(&rsa, wrappedKey->pubKey.key,
+		     &key_length);
+  wrappedKey->pubKey.keyLength = (UINT32) key_length;
+  rsa_export_prime1(&rsa, store.privKey.key, &key_length);
+  store.privKey.keyLength = (UINT32) key_length;
   rsa_release_private_key(&rsa);
   /* encrypt private key data */
   if (encrypt_private_key(parent, &store, wrappedKey->encData, 
@@ -567,6 +584,7 @@ TPM_RESULT TPM_LoadKey2(TPM_KEY_HANDLE p
 
 int tpm_setup_key_parms(TPM_KEY_DATA *key, TPM_KEY_PARMS *parms)
 {
+  size_t key_length;
   parms->algorithmID = TPM_ALG_RSA;
   parms->encScheme = key->encScheme;
   parms->sigScheme = key->sigScheme;
@@ -576,7 +594,8 @@ int tpm_setup_key_parms(TPM_KEY_DATA *ke
   parms->parms.rsa.exponent = tpm_malloc(parms->parms.rsa.exponentSize);
   if (parms->parms.rsa.exponent == NULL) return -1;
   rsa_export_exponent(&key->key, parms->parms.rsa.exponent,
-    &parms->parms.rsa.exponentSize);
+    &key_length);
+  parms->parms.rsa.exponentSize = (UINT32) key_length;
   parms->parmSize = 12 + parms->parms.rsa.exponentSize;
   return 0;
 }
@@ -587,6 +606,7 @@ TPM_RESULT TPM_GetPubKey(TPM_KEY_HANDLE 
   TPM_RESULT res;
   TPM_KEY_DATA *key;
   TPM_DIGEST digest;
+  size_t key_length;
   info("TPM_GetPubKey()");
   /* get key */
   if (keyHandle == TPM_KH_SRK) return TPM_BAD_PARAMETER;
@@ -614,8 +634,8 @@ TPM_RESULT TPM_GetPubKey(TPM_KEY_HANDLE 
   pubKey->pubKey.keyLength = key->key.size >> 3;
   pubKey->pubKey.key = tpm_malloc(pubKey->pubKey.keyLength);
   if (pubKey->pubKey.key == NULL) return TPM_FAIL;
-  rsa_export_modulus(&key->key, pubKey->pubKey.key, 
-    &pubKey->pubKey.keyLength);
+  rsa_export_modulus(&key->key, pubKey->pubKey.key, &key_length); 
+  pubKey->pubKey.keyLength = (UINT32) key_length;
   if (tpm_setup_key_parms(key, &pubKey->algorithmParms) != 0) {
     tpm_free(pubKey->pubKey.key);
     return TPM_FAIL;
diff -uprN orig/tpm_emulator-0.3/tpm/tpm_structures.h tpm_emulator-0.3-x86_64/tpm/tpm_structures.h
--- orig/tpm_emulator-0.3/tpm/tpm_structures.h	2006-01-10 04:21:45.000000000 -0800
+++ tpm_emulator-0.3-x86_64/tpm/tpm_structures.h	2006-08-29 15:08:20.545340792 -0700
@@ -1723,6 +1723,7 @@ typedef struct tdTPM_DAA_ISSUER {
   TPM_DIGEST DAA_digest_gamma;
   BYTE DAA_generic_q[26];
 } TPM_DAA_ISSUER;
+#define sizeof_TPM_DAA_ISSUER(s) (2 + (20 * 6) + 26 )
 
 /*
  * TPM_DAA_TPM ([TPM_Part2], Section 22.8)
@@ -1738,6 +1739,7 @@ typedef struct tdTPM_DAA_TPM {
   TPM_DIGEST DAA_rekey;
   UINT32 DAA_count;
 } TPM_DAA_TPM;
+#define sizeof_TPM_DAA_TPM(s) (2 + (4 * 20) + 4)
 
 /*
  * TPM_DAA_CONTEXT ([TPM_Part2], Section 22.9)
@@ -1752,6 +1754,7 @@ typedef struct tdTPM_DAA_CONTEXT {
   BYTE DAA_scratch[256];
   BYTE DAA_stage;
 } TPM_DAA_CONTEXT;
+#define sizeof_TPM_DAA_CONTEXT(s) (2 + (3 * 20) + 256 + 1)
 
 /*
  * TPM_DAA_JOINDATA ([TPM_Part2], Section 22.10)
@@ -1763,6 +1766,7 @@ typedef struct tdTPM_DAA_JOINDATA {
   BYTE DAA_join_u1[138]; /* WATCH: 138 (v1.2 rev 85) */
   TPM_DIGEST DAA_digest_n0;
 } TPM_DAA_JOINDATA;
+#define sizeof_TPM_DAA_JOINDATA(s) (1 + 1 + 20)
 
 /*
  * TPM_DAA_BLOB ([TPM_Part2], Section 22.12)
@@ -2033,6 +2037,7 @@ typedef struct tdTPM_STCLEAR_DATA {
   TPM_COUNT_ID countID;
   //UINT32 ownerReference;
 } TPM_STCLEAR_DATA;
+#define sizeof_TPM_STCLEAR_DATA(s) (2 + 20 + 4)
 
 /*
  * TPM_SESSION_DATA
@@ -2069,6 +2074,11 @@ typedef struct tdTPM_DAA_SESSION_DATA {
   TPM_DAA_JOINDATA DAA_joinSession;
   TPM_HANDLE handle;
 } TPM_DAA_SESSION_DATA;
+#define sizeof_TPM_DAA_SESSION_DATA(s) ( 1 \
+  + sizeof_TPM_DAA_ISSUER(s.DAA_issuerSettings) \
+  + sizeof_TPM_DAA_TPM(s.DAA_tpmSpecific) \
+  + sizeof_TPM_DAA_CONTEXT(s.DAA_session) \
+  + sizeof_TPM_DAA_JOINDATA(s.DAA_joinSession) + 4)
 
 /*
  * TPM_STANY_DATA ([TPM_Part2], Section 7.6)
@@ -2095,6 +2105,17 @@ typedef struct tdTPM_STANY_DATA {
   TPM_DAA_SESSION_DATA sessionsDAA[TPM_MAX_SESSIONS_DAA];
   TPM_TRANSHANDLE transExclusive;
 } TPM_STANY_DATA;
+#define sizeof_TPM_STANY_DATA(s) (2 + 20 + 20 + 1 \
+  + sizeof_TPM_CURRENT_TICKS(s.currentTicks) \
+  + 4 + (4 * TPM_MAX_SESSION_LIST) \
+  + (sizeof_TPM_SESSION_DATA(s.sessions[0]) * TPM_MAX_SESSION_LIST) \
+  + (sizeof_TPM_DAA_SESSION_DATA(s.sessionsDAA[0]) * TPM_MAX_SESSIONS_DAA) + 4)
+
+#define sizeof_TPM_PERMANENT_DATA(s) (2 + 4 + 4*20 \
+  + sizeof_RSA(s.endorsementKey) + TPM_ORD_MAX/8 \
+  + (1+TPM_MAX_KEYS)*sizeof_TPM_KEY_DATA(s.srk) \
+  + TPM_NUM_PCR*(sizeof_TPM_PCR_ATTRIBUTES(x)+20) \
+  + TPM_MAX_COUNTERS*sizeof_TPM_COUNTER_VALUE2(x) + 1 + 4 + 20)
 
 /*
  * TPM_DATA
