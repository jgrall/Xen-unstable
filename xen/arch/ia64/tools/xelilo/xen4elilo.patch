<Sign-Off: Fred.Yang@intel.com>
diff -r f2309ac2648a xen/arch/ia64/xen/dom_fw.c
--- a/xen/arch/ia64/xen/dom_fw.c	Tue Sep 20 19:03:25 2005
+++ b/xen/arch/ia64/xen/dom_fw.c	Tue Sep 20 20:10:36 2005
@@ -686,6 +686,12 @@
 	bp->console_info.orig_x = 0;
 	bp->console_info.orig_y = 24;
 	bp->fpswa = 0;
+        bp->initrd_start = (dom0_start+dom0_size) -
+                (PAGE_ALIGN(ia64_boot_param->initrd_size) + 4*1024*1024);
+        bp->initrd_size = ia64_boot_param->initrd_size;
+                printf(" initrd start %0xlx", bp->initrd_start);
+                printf(" initrd size %0xlx", bp->initrd_size);
+
 
 	return bp;
 }
diff -r f2309ac2648a xen/arch/ia64/xen/domain.c
--- a/xen/arch/ia64/xen/domain.c	Tue Sep 20 19:03:25 2005
+++ b/xen/arch/ia64/xen/domain.c	Tue Sep 20 20:10:36 2005
@@ -830,6 +830,7 @@
 	unsigned long pkern_start;
 	unsigned long pkern_entry;
 	unsigned long pkern_end;
+	unsigned long pinitrd_start = 0;
 	unsigned long ret, progress = 0;
 
 //printf("construct_dom0: starting\n");
@@ -848,12 +849,6 @@
 	alloc_start = dom0_start;
 	alloc_end = dom0_start + dom0_size;
 	d->tot_pages = d->max_pages = dom0_size/PAGE_SIZE;
-	image_start = __va(ia64_boot_param->initrd_start);
-	image_len = ia64_boot_param->initrd_size;
-//printk("image_start=%lx, image_len=%lx\n",image_start,image_len);
-//printk("First word of image: %lx\n",*(unsigned long *)image_start);
-
-//printf("construct_dom0: about to call parseelfimage\n");
 	dsi.image_addr = (unsigned long)image_start;
 	dsi.image_len  = image_len;
 	rc = parseelfimage(&dsi);
@@ -890,11 +885,18 @@
 	    return -EINVAL;
 	}
 
+        if(initrd_start&&initrd_len){
+             pinitrd_start=(dom0_start+dom0_size) -
+                          (PAGE_ALIGN(initrd_len) + 4*1024*1024);
+
+             memcpy(__va(pinitrd_start),initrd_start,initrd_len);
+        }
+
 	printk("METAPHYSICAL MEMORY ARRANGEMENT:\n"
 	       " Kernel image:  %lx->%lx\n"
 	       " Entry address: %lx\n"
-	       " Init. ramdisk:   (NOT IMPLEMENTED YET)\n",
-	       pkern_start, pkern_end, pkern_entry);
+               " Init. ramdisk: %lx len %lx\n",
+               pkern_start, pkern_end, pkern_entry, pinitrd_start, initrd_len);
 
 	if ( (pkern_end - pkern_start) > (d->max_pages * PAGE_SIZE) )
 	{
diff -r f2309ac2648a xen/arch/ia64/xen/xensetup.c
--- a/xen/arch/ia64/xen/xensetup.c	Tue Sep 20 19:03:25 2005
+++ b/xen/arch/ia64/xen/xensetup.c	Tue Sep 20 20:10:36 2005
@@ -153,7 +153,8 @@
     void *heap_start;
     int i;
     unsigned long max_mem, nr_pages, firsthole_start;
-    unsigned long dom0_memory_start, dom0_memory_end;
+    unsigned long dom0_memory_start, dom0_memory_size;
+    unsigned long dom0_initrd_start, dom0_initrd_size;
     unsigned long initial_images_start, initial_images_end;
 
     running_on_sim = is_platform_hp_ski();
@@ -191,7 +192,18 @@
     efi_memmap_walk(xen_find_first_hole, &firsthole_start);
 
     initial_images_start = xenheap_phys_end;
-    initial_images_end = initial_images_start + ia64_boot_param->initrd_size;
+    initial_images_end = initial_images_start +
+       PAGE_ALIGN(ia64_boot_param->domain_size);
+
+    /* also reserve space for initrd */
+    if (ia64_boot_param->initrd_start && ia64_boot_param->initrd_size)
+       initial_images_end += PAGE_ALIGN(ia64_boot_param->initrd_size);
+    else {
+       /* sanity cleanup */
+       ia64_boot_param->initrd_size = 0;
+       ia64_boot_param->initrd_start = 0;
+    }
+
 
     /* Later may find another memory trunk, even away from xen image... */
     if (initial_images_end > firsthole_start) {
@@ -203,11 +215,21 @@
 
     /* This copy is time consuming, but elilo may load Dom0 image
      * within xenheap range */
-    printk("ready to move Dom0 to 0x%lx...", initial_images_start);
+    printk("ready to move Dom0 to 0x%lx with len %lx...", initial_images_start,
+          ia64_boot_param->domain_size);
+
     memmove(__va(initial_images_start),
+          __va(ia64_boot_param->domain_start),
+          ia64_boot_param->domain_size);
+//    ia64_boot_param->domain_start = initial_images_start;
+
+    printk("ready to move initrd to 0x%lx with len %lx...",
+          initial_images_start+PAGE_ALIGN(ia64_boot_param->domain_size),
+          ia64_boot_param->initrd_size);
+    memmove(__va(initial_images_start+PAGE_ALIGN(ia64_boot_param->domain_size)),
+
 	   __va(ia64_boot_param->initrd_start),
 	   ia64_boot_param->initrd_size);
-    ia64_boot_param->initrd_start = initial_images_start;
     printk("Done\n");
 
     /* first find highest page frame number */
@@ -335,23 +357,26 @@
      * above our heap. The second module, if present, is an initrd ramdisk.
      */
 printk("About to call construct_dom0()\n");
-    dom0_memory_start = __va(ia64_boot_param->initrd_start);
-    dom0_memory_end = ia64_boot_param->initrd_size;
-    if ( construct_dom0(dom0, dom0_memory_start, dom0_memory_end,
-			0,
-                        0,
+    dom0_memory_start = __va(initial_images_start);
+    dom0_memory_size = ia64_boot_param->domain_size;
+    dom0_initrd_start = __va(initial_images_start +
+                       PAGE_ALIGN(ia64_boot_param->domain_size));
+    dom0_initrd_size = ia64_boot_param->initrd_size;
+
+    if ( construct_dom0(dom0, dom0_memory_start, dom0_memory_size,
+                       dom0_initrd_start,dom0_initrd_size,
 			0) != 0)
         panic("Could not set up DOM0 guest OS\n");
 #ifdef CLONE_DOMAIN0
     {
     int i;
-    dom0_memory_start = __va(ia64_boot_param->initrd_start);
-    dom0_memory_end = ia64_boot_param->initrd_size;
+    dom0_memory_start = __va(ia64_boot_param->domain_start);
+    dom0_memory_size = ia64_boot_param->domain_size;
+
     for (i = 0; i < CLONE_DOMAIN0; i++) {
 printk("CONSTRUCTING DOMAIN0 CLONE #%d\n",i+1);
-        if ( construct_domU(clones[i], dom0_memory_start, dom0_memory_end,
-                        0, 
-                        0,
+        if ( construct_domU(clones[i], dom0_memory_start, dom0_memory_size,
+                       dom0_initrd_start,dom0_initrd_size,
 			0) != 0)
             panic("Could not set up DOM0 clone %d\n",i);
     }
@@ -359,8 +384,14 @@
 #endif
 
     /* The stash space for the initial kernel image can now be freed up. */
-    init_domheap_pages(ia64_boot_param->initrd_start,
-		       ia64_boot_param->initrd_start + ia64_boot_param->initrd_size);
+    init_domheap_pages(ia64_boot_param->domain_start,
+                       ia64_boot_param->domain_size);
+    /* throw away initrd area passed from elilo */
+    if (ia64_boot_param->initrd_size) {
+        init_domheap_pages(ia64_boot_param->initrd_start,
+                          ia64_boot_param->initrd_size);
+    }
+
     if (!running_on_sim)  // slow on ski and pages are pre-initialized to zero
 	scrub_heap_pages();
 
diff -r f2309ac2648a xen/include/asm-ia64/linux-xen/asm/system.h
--- a/xen/include/asm-ia64/linux-xen/asm/system.h	Tue Sep 20 19:03:25 2005
+++ b/xen/include/asm-ia64/linux-xen/asm/system.h	Tue Sep 20 20:10:36 2005
@@ -56,6 +56,10 @@
 	__u64 fpswa;		/* physical address of the fpswa interface */
 	__u64 initrd_start;
 	__u64 initrd_size;
+//for loading initrd for dom0
+       __u64 domain_start;     /* virtual address where the boot time domain begins */
+       __u64 domain_size;      /* how big is the boot domain */
+
 } *ia64_boot_param;
 
 /*
