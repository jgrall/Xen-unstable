<Sign-off: fred.yang@intel.com>
diff -Naur base/bootparams.c elilo/bootparams.c
--- base/bootparams.c	2005-09-20 19:51:07.000000000 -0700
+++ elilo/bootparams.c	2005-09-20 19:33:00.000000000 -0700
@@ -38,7 +38,7 @@
  * 	bp  : the address of the bootparams otherwise (opaque type)
  */
 VOID *
-create_boot_params(CHAR16 *args, memdesc_t *initrd, UINTN *cookie)
+create_boot_params(CHAR16 *args, memdesc_t *initrd, memdesc_t *vmcode, UINTN *cookie)
 {
 /* 
  * XXX: need cleanup
@@ -95,7 +95,7 @@
 	 */
 	Memset(bp, 0, BOOT_PARAM_MEMSIZE);
 
-	if (sysdeps_create_boot_params(bp, cp, initrd, cookie) == -1) return 0;
+	if (sysdeps_create_boot_params(bp, cp, initrd, vmcode, cookie) == -1) return 0;
 
 	/*
 	 * Convert kernel command line args from UNICODE to ASCII and put them where
diff -Naur base/choosers/simple.c elilo/choosers/simple.c
--- base/choosers/simple.c	2005-09-20 19:51:07.000000000 -0700
+++ elilo/choosers/simple.c	2005-09-20 19:28:15.000000000 -0700
@@ -37,6 +37,7 @@
 {
 	CHAR16 *desc;
 	CHAR16 initrd_name[CMDLINE_MAXLEN];
+	CHAR16 vmcode_name[CMDLINE_MAXLEN];
 	CHAR16 options_tmp[CMDLINE_MAXLEN];
 	CHAR16 options[CMDLINE_MAXLEN];
 	CHAR16 kname[FILENAME_MAXLEN];
@@ -46,9 +47,9 @@
 		Print(L"desc   : %s\n", desc);
 	}
 
-	initrd_name[0] = options_tmp[0] = kname[0] = CHAR_NULL;
+	initrd_name[0] = vmcode_name[0] = options_tmp[0] = kname[0] = CHAR_NULL;
 
-	if (find_label(name, kname, options_tmp, initrd_name) == -1) {
+	if (find_label(name, kname, options_tmp, initrd_name, vmcode_name) == -1) {
 		StrCpy(kname, name);
 		Print(L"\n");
 	}
@@ -56,6 +57,7 @@
 
 	Print(L"cmdline: %s %s\n", kname, options);
 	if (initrd_name[0]) Print(L"initrd : %s\n", initrd_name);
+	if (vmcode_name[0]) Print(L"vmcode : %s\n", vmcode_name);
 }
 
 static VOID
@@ -247,6 +249,7 @@
 	CHAR16 buffer[CMDLINE_MAXLEN];
 	CHAR16 alt_buffer[CMDLINE_MAXLEN];
 	CHAR16 initrd_name[CMDLINE_MAXLEN];
+	CHAR16 vmcode_name[CMDLINE_MAXLEN];
 	CHAR16 args[CMDLINE_MAXLEN];
 	CHAR16 devname[CMDLINE_MAXLEN];
 	CHAR16 dpath[FILENAME_MAXLEN];
@@ -259,7 +262,7 @@
 	display_message();
 
 restart:
-	initrd_name[0] = kname[0] = cmdline[0] = args[0] = CHAR_NULL;
+	initrd_name[0] = vmcode_name[0] = kname[0] = cmdline[0] = args[0] = CHAR_NULL;
 
 	/* reset per image loader options */
 	Memset(&elilo_opt.img_opt, 0, sizeof(elilo_opt.img_opt));
@@ -303,7 +306,7 @@
 	 * if no match is found, the args and initrd arguments may
 	 * still be modified by global options in the config file.
 	 */
-	ret = find_label((index < argc) ? argv[index] : NULL, kname, args, initrd_name);
+	ret = find_label((index < argc) ? argv[index] : NULL, kname, args, initrd_name, vmcode_name);
 
 	/*
 	 * not found, so assume first argument is kernel name and
@@ -335,6 +338,10 @@
 		StrCpy(elilo_opt.initrd, initrd_name);
 	}
 
+	if (elilo_opt.vmcode[0] == CHAR_NULL && vmcode_name[0] != CHAR_NULL) {
+		StrCpy(elilo_opt.vmcode, vmcode_name);
+	}
+
 	VERB_PRT(1,  { Print(L"kernel     is  '%s'\n", kname);
 		       Print(L"arguments  are '%s'\n", args);
 			if (elilo_opt.initrd[0]) Print(L"initrd      is '%s'\n", elilo_opt.initrd);
diff -Naur base/choosers/textmenu.c elilo/choosers/textmenu.c
--- base/choosers/textmenu.c	2005-09-20 19:51:07.000000000 -0700
+++ elilo/choosers/textmenu.c	2005-09-20 19:28:29.000000000 -0700
@@ -358,6 +358,7 @@
 #	define BOOT_IMG_STR	L"BOOT_IMAGE="
 	CHAR16 label[CMDLINE_MAXLEN];
 	CHAR16 initrd_name[CMDLINE_MAXLEN];
+	CHAR16 vmcode_name[CMDLINE_MAXLEN];
 	CHAR16 args[CMDLINE_MAXLEN];
 	CHAR16 devname[CMDLINE_MAXLEN];
 	CHAR16 dpath[FILENAME_MAXLEN];
@@ -412,9 +413,9 @@
 	 * still be modified by global options in the config file.
 	 */
 	if (label[0])
-		ret = find_label(label, kname, args, initrd_name);
+		ret = find_label(label, kname, args, initrd_name, vmcode_name);
 	else
-		ret = find_label(argv[index], kname, args, initrd_name);
+		ret = find_label(argv[index], kname, args, initrd_name, vmcode_name);
 
 	/*
 	 * not found, so assume first argument is kernel name and
@@ -448,6 +449,10 @@
 		StrCpy(elilo_opt.initrd, initrd_name);
 	}
 
+	if (elilo_opt.vmcode[0] == CHAR_NULL && vmcode_name[0] != CHAR_NULL) {
+		StrCpy(elilo_opt.vmcode, vmcode_name);
+	}
+
 	VERB_PRT(1,  { Print(L"kernel     is  '%s'\n", kname);
 		       Print(L"arguments  are '%s'\n", args);
 			if (elilo_opt.initrd[0]) Print(L"initrd      is '%s'\n", elilo_opt.initrd);
diff -Naur base/config.c elilo/config.c
--- base/config.c	2005-09-20 19:51:07.000000000 -0700
+++ elilo/config.c	2005-09-20 19:33:26.000000000 -0700
@@ -68,6 +68,7 @@
 	CHAR16	kname[FILENAME_MAXLEN];
 	CHAR16  options[MAX_STRING];
 	CHAR16	initrd[FILENAME_MAXLEN];
+	CHAR16	vmcode[FILENAME_MAXLEN];
 	CHAR16	root[FILENAME_MAXLEN];
 	CHAR16	fallback[MAX_STRING];
 	CHAR16	description[MAX_STRING];
@@ -93,6 +94,7 @@
 typedef struct {
 	CHAR16		root[FILENAME_MAXLEN];	/* globally defined root fs */
 	CHAR16		initrd[FILENAME_MAXLEN];/* globally defined initrd  */
+	CHAR16		vmcode[FILENAME_MAXLEN];/* globally defined boot-time module  */
 	CHAR16		options[MAX_STRING];
 	CHAR16		default_image_name[MAX_STRING];
 	CHAR16		message_file[MAX_MESSAGES][FILENAME_MAXLEN]; 
@@ -144,6 +146,7 @@
 {OPT_BOOL,	OPT_GLOBAL,	L"noedd30",	NULL,		NULL,			&global_config.edd30_no_force},
 {OPT_CMD,	OPT_GLOBAL,	L"append",	NULL,		NULL,			global_config.options},
 {OPT_FILE,	OPT_GLOBAL,	L"initrd",	NULL,		NULL,			global_config.initrd},
+{OPT_FILE,	OPT_GLOBAL,	L"vmm",		NULL,		NULL,			global_config.vmcode},
 {OPT_FILE,	OPT_GLOBAL,	L"image",	do_image,	NULL,			opt_offsetof(kname)},
 {OPT_BOOL,	OPT_GLOBAL,	L"checkalt",	NULL,		NULL,			&global_config.alt_check},
 {OPT_STR,	OPT_GLOBAL,	L"chooser",	NULL,		check_chooser,		global_config.chooser},
@@ -168,6 +171,7 @@
     {OPT_CMD,	OPT_IMAGE,	L"append",	do_options,	NULL,	opt_offsetof(options)},
     {OPT_CMD,	OPT_IMAGE,	L"literal",	do_literal,	NULL,	NULL},
     {OPT_FILE,	OPT_IMAGE,	L"initrd",	NULL,		NULL,	opt_offsetof(initrd)},
+    {OPT_FILE,	OPT_IMAGE,	L"vmm",		NULL,		NULL,	opt_offsetof(vmcode)},
     {OPT_STR,	OPT_IMAGE,	L"label",	NULL,		NULL,	opt_offsetof(label)},
     {OPT_FILE,	OPT_IMAGE,	L"image",	do_image,	NULL,	opt_offsetof(kname)},
     {OPT_STR,	OPT_IMAGE,	L"description",	NULL,		NULL,	opt_offsetof(description)},
@@ -974,7 +978,7 @@
 }
 
 INTN
-find_label(CHAR16 *label, CHAR16 *kname, CHAR16 *options, CHAR16 *initrd)
+find_label(CHAR16 *label, CHAR16 *kname, CHAR16 *options, CHAR16 *initrd, CHAR16 *vmcode)
 {
 	boot_image_t *img;
 
@@ -1007,6 +1011,7 @@
 	if (global_config.readonly) StrCat(options, L" ro");
 
 	if (global_config.initrd[0]) StrCpy(initrd, global_config.initrd);
+	if (global_config.vmcode[0]) StrCpy(vmcode, global_config.vmcode);
 
 	/* make sure we don't get garbage here */
 	elilo_opt.sys_img_opts = NULL;
@@ -1044,12 +1049,17 @@
 	else if (global_config.initrd[0])
 		StrCpy(initrd, global_config.initrd);
 
+	if (img->vmcode[0]) 
+		StrCpy(vmcode, img->vmcode);
+	else if (global_config.vmcode[0])
+		StrCpy(vmcode, global_config.vmcode);
+
 	/*
 	 * point to architecture dependent options for this image
 	 */
 	elilo_opt.sys_img_opts = &img->sys_img_opts;
 
-	DBG_PRT((L"label %s: kname=%s options=%s initrd=%s", img->label, kname, options, initrd));
+	DBG_PRT((L"label %s: kname=%s options=%s initrd=%s vmcode=%s", img->label, kname, options, initrd, vmcode));
 
 	return 0;
 }
diff -Naur base/elilo.c elilo/elilo.c
--- base/elilo.c	2005-09-20 19:51:07.000000000 -0700
+++ elilo/elilo.c	2005-09-20 19:33:41.000000000 -0700
@@ -84,10 +84,23 @@
 }
 
 INTN
-kernel_load(EFI_HANDLE image, CHAR16 *kname, kdesc_t *kd, memdesc_t *imem)
+kernel_load(EFI_HANDLE image, CHAR16 *kname, kdesc_t *kd, memdesc_t *imem, memdesc_t *mmem)
 {
 
 	/*
+	 * Do the vm image switch here
+	 * if there is "vmm=" then elilo should load image specified
+	 *    in "vmm=" and then give the "image" to vmm as target kernel image
+	 */
+	if (elilo_opt.vmcode[0]) {
+		CHAR16 buffer[CMDLINE_MAXLEN];
+	VERB_PRT(1,Print(L"swapping vmm=%s with image=%s\n", elilo_opt.vmcode,
+			kname));
+		StrCpy(buffer, kname);
+		StrCpy(kname, elilo_opt.vmcode);
+		StrCpy(elilo_opt.vmcode, buffer);
+	}
+	/*
 	 * Now let's try to load the kernel !
 	 */
 	switch(do_kernel_load(kname, kd)) {
@@ -134,10 +147,32 @@
 				return ELILO_LOAD_RETRY;
 		}
 	}
+
+	if (elilo_opt.vmcode[0]) {
+
+		mmem->start_addr = 0; /* let the allocator decide */
+
+		switch(load_initrd(elilo_opt.vmcode, mmem)) {
+			case ELILO_LOAD_SUCCESS:
+				break;
+			case ELILO_LOAD_ERROR:
+				goto exit_error;
+			case ELILO_LOAD_ABORTED:
+				free_kmem();
+				/* we drop initrd in case we aborted the load */
+				elilo_opt.vmcode[0] = CHAR_NULL;
+				elilo_opt.prompt    = 1; 
+				elilo_opt.timeout   = ELILO_DEFAULT_TIMEOUT;
+				elilo_opt.delay     = 0;
+
+				return ELILO_LOAD_RETRY;
+		}
+	}
 	return ELILO_LOAD_SUCCESS;
 exit_error:
 	free_kmem();
 	if (imem->start_addr) free(imem->start_addr);
+	if (mmem->start_addr) free(mmem->start_addr);
 
 	return ELILO_LOAD_ERROR;
 }
@@ -152,7 +187,7 @@
 	UINTN cookie;
 	EFI_STATUS status = EFI_SUCCESS;
 	kdesc_t kd;
-	memdesc_t imem;
+	memdesc_t imem, mmem;
 	INTN r;
 
 	/*
@@ -169,7 +204,7 @@
 
 		if (kernel_chooser(argv, argc, index, kname, cmdline_tmp) == -1) goto exit_error;
 
-		switch (kernel_load(image, kname, &kd, &imem)) {
+		switch (kernel_load(image, kname, &kd, &imem, &mmem)) {
 			case ELILO_LOAD_SUCCESS: 
 				goto do_launch;
 			case ELILO_LOAD_ERROR:
@@ -187,7 +222,7 @@
 	close_devices();
 
 	/* No console output permitted after create_boot_params()! */
-	if ((bp=create_boot_params(cmdline, &imem, &cookie)) == 0) goto error;
+	if ((bp=create_boot_params(cmdline, &imem, &mmem, &cookie)) == 0) goto error;
 
 	/* terminate bootservices */
 	status = BS->ExitBootServices(image, cookie);
@@ -221,6 +256,7 @@
 	Print(L"-v        verbose level(can appear multiple times)\n");
 	Print(L"-a        always check for alternate kernel image\n");
 	Print(L"-i file   load file as the initial ramdisk\n");
+	Print(L"-m file   load file as additional boot time vmm module\n");
 	Print(L"-C file   indicate the config file to use\n");
 	Print(L"-P        parse config file only (verify syntax)\n");
 	Print(L"-D        enable debug prints\n");
@@ -491,6 +527,13 @@
 				}
 				StrCpy(elilo_opt.initrd, Optarg);
 				break;
+			case 'm':
+				if (StrLen(Optarg) >= FILENAME_MAXLEN-1) {
+					Print(L"vmm module filename is limited to %d characters\n", FILENAME_MAXLEN);
+					goto do_exit;
+				}
+				StrCpy(elilo_opt.vmcode, Optarg);
+				break;
 			case 'C':
 				if (StrLen(Optarg) >= FILENAME_MAXLEN-1) {
 					Print(L"config filename is limited to %d characters\n", FILENAME_MAXLEN);
diff -Naur base/elilo.h elilo/elilo.h
--- base/elilo.h	2005-09-20 19:51:07.000000000 -0700
+++ elilo/elilo.h	2005-09-20 19:32:19.000000000 -0700
@@ -75,6 +75,7 @@
 	UINTN delay;		/* delay before booting the image */
 	UINTN verbose;		/* verbosity level [1-5] */
 	CHAR16 initrd[FILENAME_MAXLEN];		/* name of file for initial ramdisk */
+	CHAR16 vmcode[FILENAME_MAXLEN];	/* name of file for boot time module*/
 	UINT8 delay_set;	/* mark whether or not delay was specified on cmdline */
 	UINT8 edd30_on;		/* true is EDD30 variable is TRUE */
 	UINT8 edd30_no_force;	/* don't force EDD30 variable to true */
@@ -131,7 +132,7 @@
 #endif
 
 #define VERB_PRT(n,cmd) \
-	{ if (elilo_opt.verbose >= (n)) { cmd; } }
+  { if (elilo_opt.verbose >= (n)) { cmd; } }
 
 
 /* from alloc.c */
@@ -163,7 +164,7 @@
 /* from config.c (more in config.h) */
 extern EFI_STATUS read_config(CHAR16 *, INTN retry);
 extern VOID print_config_options(VOID);
-extern INTN find_label(CHAR16 *, CHAR16 *, CHAR16 *, CHAR16 *);
+extern INTN find_label(CHAR16 *, CHAR16 *, CHAR16 *, CHAR16 *, CHAR16 *);
 extern VOID print_label_list(VOID);
 extern INTN config_init(VOID);
 extern CHAR16 *get_message_filename(INTN which);
@@ -178,7 +179,7 @@
 extern INTN alternate_kernel(CHAR16 *, INTN);
 
 /* from bootparams.c */
-extern VOID *create_boot_params (CHAR16 *, memdesc_t *, UINTN *);
+extern VOID *create_boot_params (CHAR16 *, memdesc_t *, memdesc_t *, UINTN *);
 extern VOID free_boot_params(VOID *bp);
 
 /*
@@ -186,7 +187,7 @@
  */
 
 
-extern INTN sysdeps_create_boot_params(boot_params_t *, CHAR8 *, memdesc_t *, UINTN *);
+extern INTN sysdeps_create_boot_params(boot_params_t *, CHAR8 *, memdesc_t *, memdesc_t *, UINTN *);
 extern VOID sysdeps_free_boot_params(boot_params_t *);
 extern INTN sysdeps_init(EFI_HANDLE dev);
 extern INTN sysdeps_initrd_get_addr(kdesc_t *, memdesc_t *);
diff -Naur base/ia32/system.c elilo/ia32/system.c
--- base/ia32/system.c	2005-09-20 19:51:07.000000000 -0700
+++ elilo/ia32/system.c	2005-09-20 19:30:10.000000000 -0700
@@ -408,6 +408,7 @@
 	boot_params_t *bp,
 	CHAR8 *cmdline,
 	memdesc_t *initrd,
+	memdesc_t *vmcode, /* no use for ia32 now*/
 	UINTN *cookie)
 {
 	mmap_desc_t mdesc;
diff -Naur base/ia64/sysdeps.h elilo/ia64/sysdeps.h
--- base/ia64/sysdeps.h	2005-09-20 19:51:07.000000000 -0700
+++ elilo/ia64/sysdeps.h	2005-09-20 19:29:07.000000000 -0700
@@ -65,8 +65,11 @@
 	UINTN initrd_start;		/* virtual address where the initial ramdisk begins */
 	UINTN initrd_size;		/* how big is the initial ramdisk */
 
+	UINTN vmcode_start;		/* virtual address where the boot time vmcode begins */
+	UINTN vmcode_size;		/* how big is the boot module */
 	UINTN loader_addr;		/* start address of boot loader */
 	UINTN loader_size;		/* size of loader code & data */
+
 } boot_params_t;
 
 typedef struct sys_img_options {
diff -Naur base/ia64/system.c elilo/ia64/system.c
--- base/ia64/system.c	2005-09-20 19:51:07.000000000 -0700
+++ elilo/ia64/system.c	2005-09-20 19:29:28.000000000 -0700
@@ -39,7 +39,7 @@
  * IA-64 specific boot paramters initialization routine
  */
 INTN
-sysdeps_create_boot_params(boot_params_t *bp, CHAR8 *cmdline, memdesc_t *initrd, UINTN *cookie)
+sysdeps_create_boot_params(boot_params_t *bp, CHAR8 *cmdline, memdesc_t *initrd, memdesc_t *vmcode, UINTN *cookie)
 {
 	UINTN cols, rows;
 	SIMPLE_TEXT_OUTPUT_INTERFACE *conout;
@@ -65,6 +65,11 @@
 	bp->command_line	= (UINTN)cmdline;
 	bp->initrd_start	= (UINTN) initrd->start_addr;
 	bp->initrd_size		= initrd->size;
+	DBG_PRT((L"Got initrd @ 0x%lx (%d bytes)", initrd->start_addr, initrd->size));
+
+	bp->vmcode_start	= (UINTN) vmcode->start_addr;
+	bp->vmcode_size		= vmcode->size;
+	DBG_PRT((L"Got vmcode @ 0x%lx (%d bytes)", vmcode->start_addr, vmcode->size));
 
 	/* fetch console parameters: */
 	conout = systab->ConOut;
