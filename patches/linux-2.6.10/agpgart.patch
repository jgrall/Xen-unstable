diff -ur linux-2.6.9/drivers/char/agp/ali-agp.c linux-2.6.9-new/drivers/char/agp/ali-agp.c
--- linux-2.6.9/drivers/char/agp/ali-agp.c	2004-10-18 22:54:38.000000000 +0100
+++ linux-2.6.9-new/drivers/char/agp/ali-agp.c	2004-11-28 19:32:03.000000000 +0000
@@ -150,7 +150,7 @@
 	pci_read_config_dword(agp_bridge->dev, ALI_CACHE_FLUSH_CTRL, &temp);
 	pci_write_config_dword(agp_bridge->dev, ALI_CACHE_FLUSH_CTRL,
 			(((temp & ALI_CACHE_FLUSH_ADDR_MASK) |
-			  virt_to_phys(addr)) | ALI_CACHE_FLUSH_EN ));
+			  virt_to_bus(addr)) | ALI_CACHE_FLUSH_EN ));
 	return addr;
 }
 
@@ -174,7 +174,7 @@
 	pci_read_config_dword(agp_bridge->dev, ALI_CACHE_FLUSH_CTRL, &temp);
 	pci_write_config_dword(agp_bridge->dev, ALI_CACHE_FLUSH_CTRL,
 			(((temp & ALI_CACHE_FLUSH_ADDR_MASK) |
-			  virt_to_phys(addr)) | ALI_CACHE_FLUSH_EN));
+			  virt_to_bus(addr)) | ALI_CACHE_FLUSH_EN));
 	agp_generic_destroy_page(addr);
 }
 
diff -ur linux-2.6.9/drivers/char/agp/amd-k7-agp.c linux-2.6.9-new/drivers/char/agp/amd-k7-agp.c
--- linux-2.6.9/drivers/char/agp/amd-k7-agp.c	2004-10-18 22:55:36.000000000 +0100
+++ linux-2.6.9-new/drivers/char/agp/amd-k7-agp.c	2004-11-28 19:36:39.000000000 +0000
@@ -43,7 +43,7 @@
 
 	SetPageReserved(virt_to_page(page_map->real));
 	global_cache_flush();
-	page_map->remapped = ioremap_nocache(virt_to_phys(page_map->real),
+	page_map->remapped = ioremap_nocache(virt_to_bus(page_map->real),
 					    PAGE_SIZE);
 	if (page_map->remapped == NULL) {
 		ClearPageReserved(virt_to_page(page_map->real));
@@ -152,7 +152,7 @@
 
 	agp_bridge->gatt_table_real = (u32 *)page_dir.real;
 	agp_bridge->gatt_table = (u32 __iomem *)page_dir.remapped;
-	agp_bridge->gatt_bus_addr = virt_to_phys(page_dir.real);
+	agp_bridge->gatt_bus_addr = virt_to_bus(page_dir.real);
 
 	/* Get the address for the gart region.
 	 * This is a bus address even on the alpha, b/c its
@@ -165,7 +165,7 @@
 
 	/* Calculate the agp offset */
 	for (i = 0; i < value->num_entries / 1024; i++, addr += 0x00400000) {
-		writel(virt_to_phys(amd_irongate_private.gatt_pages[i]->real) | 1,
+		writel(virt_to_bus(amd_irongate_private.gatt_pages[i]->real) | 1,
 			page_dir.remapped+GET_PAGE_DIR_OFF(addr));
 	}
 
diff -ur linux-2.6.9/drivers/char/agp/amd64-agp.c linux-2.6.9-new/drivers/char/agp/amd64-agp.c
--- linux-2.6.9/drivers/char/agp/amd64-agp.c	2004-10-18 22:54:38.000000000 +0100
+++ linux-2.6.9-new/drivers/char/agp/amd64-agp.c	2004-11-28 19:32:03.000000000 +0000
@@ -212,7 +212,7 @@
 
 static int amd_8151_configure(void)
 {
-	unsigned long gatt_bus = virt_to_phys(agp_bridge->gatt_table_real);
+	unsigned long gatt_bus = virt_to_bus(agp_bridge->gatt_table_real);
 
 	/* Configure AGP regs in each x86-64 host bridge. */
 	for_each_nb() {
@@ -521,7 +521,7 @@
 {
 	struct agp_bridge_data *bridge = pci_get_drvdata(pdev);
 
-	release_mem_region(virt_to_phys(bridge->gatt_table_real),
+	release_mem_region(virt_to_bus(bridge->gatt_table_real),
 			   amd64_aperture_sizes[bridge->aperture_size_idx].size);
 	agp_remove_bridge(bridge);
 	agp_put_bridge(bridge);
diff -ur linux-2.6.9/drivers/char/agp/ati-agp.c linux-2.6.9-new/drivers/char/agp/ati-agp.c
--- linux-2.6.9/drivers/char/agp/ati-agp.c	2004-10-18 22:54:40.000000000 +0100
+++ linux-2.6.9-new/drivers/char/agp/ati-agp.c	2004-11-28 19:32:03.000000000 +0000
@@ -64,7 +64,7 @@
 
 	/* CACHE_FLUSH(); */
 	global_cache_flush();
-	page_map->remapped = ioremap_nocache(virt_to_phys(page_map->real),
+	page_map->remapped = ioremap_nocache(virt_to_bus(page_map->real),
 					    PAGE_SIZE);
 	if (page_map->remapped == NULL || err) {
 		ClearPageReserved(virt_to_page(page_map->real));
diff -ur linux-2.6.9/drivers/char/agp/backend.c linux-2.6.9-new/drivers/char/agp/backend.c
--- linux-2.6.9/drivers/char/agp/backend.c	2004-10-18 22:54:39.000000000 +0100
+++ linux-2.6.9-new/drivers/char/agp/backend.c	2004-11-28 19:32:03.000000000 +0000
@@ -142,7 +142,7 @@
 			return -ENOMEM;
 		}
 
-		bridge->scratch_page_real = virt_to_phys(addr);
+		bridge->scratch_page_real = virt_to_bus(addr);
 		bridge->scratch_page =
 		    bridge->driver->mask_memory(bridge->scratch_page_real, 0);
 	}
@@ -186,7 +186,7 @@
 err_out:
 	if (bridge->driver->needs_scratch_page)
 		bridge->driver->agp_destroy_page(
-				phys_to_virt(bridge->scratch_page_real));
+				bus_to_virt(bridge->scratch_page_real));
 	if (got_gatt)
 		bridge->driver->free_gatt_table();
 	if (got_keylist) {
@@ -211,7 +211,7 @@
 	if (bridge->driver->agp_destroy_page &&
 	    bridge->driver->needs_scratch_page)
 		bridge->driver->agp_destroy_page(
-				phys_to_virt(bridge->scratch_page_real));
+				bus_to_virt(bridge->scratch_page_real));
 }
 
 static const drm_agp_t drm_agp = {
diff -ur linux-2.6.9/drivers/char/agp/efficeon-agp.c linux-2.6.9-new/drivers/char/agp/efficeon-agp.c
--- linux-2.6.9/drivers/char/agp/efficeon-agp.c	2004-10-18 22:53:06.000000000 +0100
+++ linux-2.6.9-new/drivers/char/agp/efficeon-agp.c	2004-11-28 19:38:28.000000000 +0000
@@ -219,7 +219,7 @@
 
 		efficeon_private.l1_table[index] = page;
 
-		value = __pa(page) | pati | present | index;
+		value = virt_to_bus(page) | pati | present | index;
 
 		pci_write_config_dword(agp_bridge->dev,
 			EFFICEON_ATTPAGE, value);
diff -ur linux-2.6.9/drivers/char/agp/generic.c linux-2.6.9-new/drivers/char/agp/generic.c
--- linux-2.6.9/drivers/char/agp/generic.c	2004-10-18 22:53:50.000000000 +0100
+++ linux-2.6.9-new/drivers/char/agp/generic.c	2004-11-28 19:32:03.000000000 +0000
@@ -128,7 +128,7 @@
 	}
 	if (curr->page_count != 0) {
 		for (i = 0; i < curr->page_count; i++) {
-			agp_bridge->driver->agp_destroy_page(phys_to_virt(curr->memory[i]));
+			agp_bridge->driver->agp_destroy_page(bus_to_virt(curr->memory[i]));
 		}
 	}
 	agp_free_key(curr->key);
@@ -182,7 +182,7 @@
 			return NULL;
 		}
 		new->memory[i] =
-			agp_bridge->driver->mask_memory(virt_to_phys(addr), type);
+			agp_bridge->driver->mask_memory(virt_to_bus(addr), type);
 		new->page_count++;
 	}
 
@@ -637,6 +637,7 @@
 	int i;
 	void *temp;
 	struct page *page;
+	dma_addr_t dma;
 
 	/* The generic routines can't handle 2 level gatt's */
 	if (agp_bridge->driver->size_type == LVL2_APER_SIZE)
@@ -675,8 +676,10 @@
 				break;
 			}
 
-			table = (char *) __get_free_pages(GFP_KERNEL,
-							  page_order);
+			table = dma_alloc_coherent(
+					&agp_bridge->dev->dev,
+					PAGE_SIZE << page_order, &dma,
+					GFP_KERNEL);
 
 			if (table == NULL) {
 				i++;
@@ -707,7 +710,9 @@
 		size = ((struct aper_size_info_fixed *) temp)->size;
 		page_order = ((struct aper_size_info_fixed *) temp)->page_order;
 		num_entries = ((struct aper_size_info_fixed *) temp)->num_entries;
-		table = (char *) __get_free_pages(GFP_KERNEL, page_order);
+		table = dma_alloc_coherent(
+				&agp_bridge->dev->dev,
+				PAGE_SIZE << page_order, &dma, GFP_KERNEL);
 	}
 
 	if (table == NULL)
@@ -722,7 +727,7 @@
 	agp_gatt_table = (void *)table;
 
 	agp_bridge->driver->cache_flush();
-	agp_bridge->gatt_table = ioremap_nocache(virt_to_phys(table),
+	agp_bridge->gatt_table = ioremap_nocache(virt_to_bus(table),
 					(PAGE_SIZE * (1 << page_order)));
 	agp_bridge->driver->cache_flush();
 
@@ -730,11 +735,12 @@
 		for (page = virt_to_page(table); page <= virt_to_page(table_end); page++)
 			ClearPageReserved(page);
 
-		free_pages((unsigned long) table, page_order);
+		dma_free_coherent(&agp_bridge->dev->dev, PAGE_SIZE<<page_order,
+					table, dma);
 
 		return -ENOMEM;
 	}
-	agp_bridge->gatt_bus_addr = virt_to_phys(agp_bridge->gatt_table_real);
+	agp_bridge->gatt_bus_addr = virt_to_bus(table);
 
 	/* AK: bogus, should encode addresses > 4GB */
 	for (i = 0; i < num_entries; i++)
@@ -786,7 +792,8 @@
 	for (page = virt_to_page(table); page <= virt_to_page(table_end); page++)
 		ClearPageReserved(page);
 
-	free_pages((unsigned long) agp_bridge->gatt_table_real, page_order);
+	dma_free_coherent(&agp_bridge->dev->dev, PAGE_SIZE<<page_order,
+		agp_bridge->gatt_table_real, agp_bridge->gatt_bus_addr);
 
 	agp_gatt_table = NULL;
 	agp_bridge->gatt_table = NULL;
diff -ur linux-2.6.9/drivers/char/agp/hp-agp.c linux-2.6.9-new/drivers/char/agp/hp-agp.c
--- linux-2.6.9/drivers/char/agp/hp-agp.c	2004-10-18 22:54:55.000000000 +0100
+++ linux-2.6.9-new/drivers/char/agp/hp-agp.c	2004-11-28 19:32:03.000000000 +0000
@@ -110,7 +110,7 @@
 	hp->gart_size = HP_ZX1_GART_SIZE;
 	hp->gatt_entries = hp->gart_size / hp->io_page_size;
 
-	hp->io_pdir = phys_to_virt(INREG64(hp->ioc_regs, HP_ZX1_PDIR_BASE));
+	hp->io_pdir = bus_to_virt(INREG64(hp->ioc_regs, HP_ZX1_PDIR_BASE));
 	hp->gatt = &hp->io_pdir[HP_ZX1_IOVA_TO_PDIR(hp->gart_base)];
 
 	if (hp->gatt[0] != HP_ZX1_SBA_IOMMU_COOKIE) {
@@ -248,7 +248,7 @@
 	agp_bridge->mode = INREG32(hp->lba_regs, hp->lba_cap_offset + PCI_AGP_STATUS);
 
 	if (hp->io_pdir_owner) {
-		OUTREG64(hp->ioc_regs, HP_ZX1_PDIR_BASE, virt_to_phys(hp->io_pdir));
+		OUTREG64(hp->ioc_regs, HP_ZX1_PDIR_BASE, virt_to_bus(hp->io_pdir));
 		OUTREG64(hp->ioc_regs, HP_ZX1_TCNFG, hp->io_tlb_ps);
 		OUTREG64(hp->ioc_regs, HP_ZX1_IMASK, ~(HP_ZX1_IOVA_SIZE - 1));
 		OUTREG64(hp->ioc_regs, HP_ZX1_IBASE, hp->iova_base | 0x1);
diff -ur linux-2.6.9/drivers/char/agp/i460-agp.c linux-2.6.9-new/drivers/char/agp/i460-agp.c
--- linux-2.6.9/drivers/char/agp/i460-agp.c	2004-10-18 22:54:32.000000000 +0100
+++ linux-2.6.9-new/drivers/char/agp/i460-agp.c	2004-11-28 19:32:03.000000000 +0000
@@ -371,7 +371,7 @@
 	}
 	memset(lp->alloced_map, 0, map_size);
 
-	lp->paddr = virt_to_phys(lpage);
+	lp->paddr = virt_to_bus(lpage);
 	lp->refcount = 0;
 	atomic_add(I460_KPAGES_PER_IOPAGE, &agp_bridge->current_memory_agp);
 	return 0;
@@ -382,7 +382,7 @@
 	kfree(lp->alloced_map);
 	lp->alloced_map = NULL;
 
-	free_pages((unsigned long) phys_to_virt(lp->paddr), I460_IO_PAGE_SHIFT - PAGE_SHIFT);
+	free_pages((unsigned long) bus_to_virt(lp->paddr), I460_IO_PAGE_SHIFT - PAGE_SHIFT);
 	atomic_sub(I460_KPAGES_PER_IOPAGE, &agp_bridge->current_memory_agp);
 }
 
diff -ur linux-2.6.9/drivers/char/agp/intel-agp.c linux-2.6.9-new/drivers/char/agp/intel-agp.c
--- linux-2.6.9/drivers/char/agp/intel-agp.c	2004-10-18 22:54:08.000000000 +0100
+++ linux-2.6.9-new/drivers/char/agp/intel-agp.c	2004-11-28 19:37:22.000000000 +0000
@@ -285,7 +285,7 @@
 	if (new == NULL)
 		return NULL;
 
-	new->memory[0] = virt_to_phys(addr);
+	new->memory[0] = virt_to_bus(addr);
 	if (pg_count == 4) {
 		/* kludge to get 4 physical pages for ARGB cursor */
 		new->memory[1] = new->memory[0] + PAGE_SIZE;
@@ -328,10 +328,10 @@
 	agp_free_key(curr->key);
 	if(curr->type == AGP_PHYS_MEMORY) {
 		if (curr->page_count == 4)
-			i8xx_destroy_pages(phys_to_virt(curr->memory[0]));
+			i8xx_destroy_pages(bus_to_virt(curr->memory[0]));
 		else
 			agp_bridge->driver->agp_destroy_page(
-				 phys_to_virt(curr->memory[0]));
+				 bus_to_virt(curr->memory[0]));
 		vfree(curr->memory);
 	}
 	kfree(curr);
diff -ur linux-2.6.9/drivers/char/agp/intel-mch-agp.c linux-2.6.9-new/drivers/char/agp/intel-mch-agp.c
--- linux-2.6.9/drivers/char/agp/intel-mch-agp.c	2004-10-18 22:53:13.000000000 +0100
+++ linux-2.6.9-new/drivers/char/agp/intel-mch-agp.c	2004-11-28 19:32:03.000000000 +0000
@@ -51,7 +51,7 @@
 	if (new == NULL)
 		return NULL;
 
-	new->memory[0] = agp_bridge->driver->mask_memory(virt_to_phys(addr), type);
+	new->memory[0] = agp_bridge->driver->mask_memory(virt_to_bus(addr), type);
 	new->page_count = 1;
 	new->num_scratch_pages = 1;
 	new->type = AGP_PHYS_MEMORY;
@@ -63,7 +63,7 @@
 {
 	agp_free_key(curr->key);
 	if(curr->type == AGP_PHYS_MEMORY) {
-		agp_bridge->driver->agp_destroy_page(phys_to_virt(curr->memory[0]));
+		agp_bridge->driver->agp_destroy_page(bus_to_virt(curr->memory[0]));
 		vfree(curr->memory);
 	}
 	kfree(curr);
diff -ur linux-2.6.9/drivers/char/agp/sworks-agp.c linux-2.6.9-new/drivers/char/agp/sworks-agp.c
--- linux-2.6.9/drivers/char/agp/sworks-agp.c	2004-10-18 22:53:50.000000000 +0100
+++ linux-2.6.9-new/drivers/char/agp/sworks-agp.c	2004-11-28 19:38:02.000000000 +0000
@@ -51,7 +51,7 @@
 	}
 	SetPageReserved(virt_to_page(page_map->real));
 	global_cache_flush();
-	page_map->remapped = ioremap_nocache(virt_to_phys(page_map->real), 
+	page_map->remapped = ioremap_nocache(virt_to_bus(page_map->real), 
 					    PAGE_SIZE);
 	if (page_map->remapped == NULL) {
 		ClearPageReserved(virt_to_page(page_map->real));
@@ -162,7 +162,7 @@
 	/* Create a fake scratch directory */
 	for(i = 0; i < 1024; i++) {
 		writel(agp_bridge->scratch_page, serverworks_private.scratch_dir.remapped+i);
-		writel(virt_to_phys(serverworks_private.scratch_dir.real) | 1, page_dir.remapped+i);
+		writel(virt_to_bus(serverworks_private.scratch_dir.real) | 1, page_dir.remapped+i);
 	}
 
 	retval = serverworks_create_gatt_pages(value->num_entries / 1024);
@@ -174,7 +174,7 @@
 
 	agp_bridge->gatt_table_real = (u32 *)page_dir.real;
 	agp_bridge->gatt_table = (u32 __iomem *)page_dir.remapped;
-	agp_bridge->gatt_bus_addr = virt_to_phys(page_dir.real);
+	agp_bridge->gatt_bus_addr = virt_to_bus(page_dir.real);
 
 	/* Get the address for the gart region.
 	 * This is a bus address even on the alpha, b/c its
@@ -187,7 +187,7 @@
 	/* Calculate the agp offset */	
 
 	for(i = 0; i < value->num_entries / 1024; i++)
-		writel(virt_to_phys(serverworks_private.gatt_pages[i]->real)|1, page_dir.remapped+i);
+		writel(virt_to_bus(serverworks_private.gatt_pages[i]->real)|1, page_dir.remapped+i);
 
 	return 0;
 }
diff -ur linux-2.6.9/drivers/char/agp/uninorth-agp.c linux-2.6.9-new/drivers/char/agp/uninorth-agp.c
--- linux-2.6.9/drivers/char/agp/uninorth-agp.c	2004-10-18 22:54:29.000000000 +0100
+++ linux-2.6.9-new/drivers/char/agp/uninorth-agp.c	2004-11-28 19:32:03.000000000 +0000
@@ -200,7 +200,7 @@
 
 	agp_bridge->gatt_table_real = (u32 *) table;
 	agp_bridge->gatt_table = (u32 *)table;
-	agp_bridge->gatt_bus_addr = virt_to_phys(table);
+	agp_bridge->gatt_bus_addr = virt_to_bus(table);
 
 	for (i = 0; i < num_entries; i++) {
 		agp_bridge->gatt_table[i] =
diff -ur linux-2.6.9/include/asm-i386/agp.h linux-2.6.9-new/include/asm-i386/agp.h
--- linux-2.6.9/include/asm-i386/agp.h	2004-10-18 22:53:06.000000000 +0100
+++ linux-2.6.9-new/include/asm-i386/agp.h	2004-11-28 19:32:03.000000000 +0000
@@ -3,6 +3,7 @@
 
 #include <asm/pgtable.h>
 #include <asm/cacheflush.h>
+#include <asm/system.h>
 
 /* 
  * Functions to keep the agpgart mappings coherent with the MMU.
@@ -19,6 +20,6 @@
 /* Could use CLFLUSH here if the cpu supports it. But then it would
    need to be called for each cacheline of the whole page so it may not be 
    worth it. Would need a page for it. */
-#define flush_agp_cache() asm volatile("wbinvd":::"memory")
+#define flush_agp_cache() wbinvd()
 
 #endif
